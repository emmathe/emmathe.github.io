<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>amy acker blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-02T20:42:05.396Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>amy acker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap中hash算法详解</title>
    <link href="http://yoursite.com/2021/06/01/HashMap%E4%B8%ADhash%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2021/06/01/HashMap中hash算法详解/</id>
    <published>2021-06-01T13:01:58.000Z</published>
    <updated>2021-06-02T20:42:05.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HashMap中hash算法（扰动函数）详解</p><a id="more"></a><h2 id="hash源码"><a href="#hash源码" class="headerlink" title="hash源码"></a>hash源码</h2><p>HashMap中是如何根据key来计算出对应的bucket呢，下面通过源码来分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="看完上面的源码我们可以简单的分析下实现步骤"><a href="#看完上面的源码我们可以简单的分析下实现步骤" class="headerlink" title="看完上面的源码我们可以简单的分析下实现步骤"></a>看完上面的源码我们可以简单的分析下实现步骤</h4><ol><li>计算key的hashCode</li><li>再根据hashCode进行无符号右移16位</li><li>再把两者（高16位和低16位）进行异或</li><li>再和(n - 1)进行与运算</li></ol><h4 id="下面我们根据步骤尝试计算下"><a href="#下面我们根据步骤尝试计算下" class="headerlink" title="下面我们根据步骤尝试计算下"></a>下面我们根据步骤尝试计算下</h4><table><thead><tr><th>hash运算步骤</th><th>32位二进制</th></tr></thead><tbody><tr><td>h = key.hashCode()</td><td>0100 1001 1010 0110 1101 1010 1011 0111</td></tr><tr><td>h &gt;&gt;&gt; 16</td><td>0000 0000 0000 0000 0100 1001 1010 0110</td></tr><tr><td>hash = h ^ (h &gt;&gt;&gt; 16)</td><td>0100 1001 1010 0110 1001 0011 0001 0001</td></tr><tr><td>(n - 1)</td><td>0000 0000 0000 0000 0000 0000 0000 1111</td></tr><tr><td>i = (n - 1) &amp; hash</td><td>0000 0000 0000 0000 0000 0000 0000 0001</td></tr></tbody></table><p>假设hashCode为0100 1001 1010 0110 1101 1010 1011 0111，我们计算出最后该值会分配到bucket1中。</p><blockquote><p>这里对于hashCode计算就不阐述了</p></blockquote><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>看完上面的分析之后，我们可能有些疑惑，为什么要根据hashCode进行无符号右移16位（<strong>h &gt;&gt;&gt; 16</strong>），再进行高低位的异或操作呢</p><p>假设把<strong>h ^ (h &gt;&gt;&gt; 16)</strong>这步骤去掉的话，我们不难发现当bucket的数量很少时，<strong>n-1</strong>的高位永远都是0，如果这时出现了高位不同，低位相同的hashCode的话，那么都只是与<strong>n-1</strong>进行低位的按位与运算。如果加上<strong>h ^ (h &gt;&gt;&gt; 16)</strong>这步骤，让高位也能参加到计算，就能有效的避免遇到高位不同，低位相同的数值时发生的哈希碰撞。</p><h4 id="不进行无符号右移16位的列子"><a href="#不进行无符号右移16位的列子" class="headerlink" title="不进行无符号右移16位的列子"></a>不进行无符号右移16位的列子</h4><table><thead><tr><th>步骤</th><th>二进制</th><th>二进制</th></tr></thead><tbody><tr><td>hash = key.hashCode()</td><td>0100 1001 1010 0000 <strong>1101 1010 1011 0111</strong></td><td>0100 0001 1010 0110 <strong>1101 1010 1011 0111</strong></td></tr><tr><td>(n - 1)</td><td>0000 0000 0000 0000 0000 0000 0000 1111</td><td>0000 0000 0000 0000 0000 0000 0000 1111</td></tr><tr><td>i = (n - 1) &amp; hash</td><td>0000 0000 0000 0000 0000 0000 0000 0111</td><td>0000 0000 0000 0000 0000 0000 0000 0111</td></tr></tbody></table><h4 id="进行无符号右移16位的列子"><a href="#进行无符号右移16位的列子" class="headerlink" title="进行无符号右移16位的列子"></a>进行无符号右移16位的列子</h4><table><thead><tr><th>步骤</th><th>二进制</th><th>二进制</th></tr></thead><tbody><tr><td>h = key.hashCode()</td><td>0100 1001 1010 0000 <strong>1101 1010 1011 0111</strong></td><td>0100 0001 1010 0110 <strong>1101 1010 1011 0111</strong></td></tr><tr><td>h &gt;&gt;&gt; 16</td><td>0000 0000 0000 0000 0100 1001 1010 0000</td><td>0000 0000 0000 0000 0100 0001 1010 0110</td></tr><tr><td>hash = h ^ (h &gt;&gt;&gt; 16)</td><td>0100 1001 1010 0000 1001 0011 0001 0111</td><td>0100 1001 1010 0000 1001 1011 0001 0001</td></tr><tr><td>(n - 1)</td><td>0000 0000 0000 0000 0000 0000 0000 0111</td><td>0000 0000 0000 0000 0000 0000 0000 0111</td></tr><tr><td>i = (n - 1) &amp; hash</td><td>0000 0000 0000 0000 0000 0000 0000 0111</td><td>0000 0000 0000 0000 0000 0000 0000 0001</td></tr></tbody></table><p>上面列子可以看出，在遇到高位不同，低位相同的hashCode时，不进行无符号右移操作的列子发生了哈希碰撞，进去无符号右移的列子则没发生哈希碰撞</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>之所以进行无符号右移16位（<strong>h ^ (h &gt;&gt;&gt; 16)</strong>）的操作，是因为可以有效避免遇到高位不同，低位相同的hash时的哈希碰撞。</p><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>在进行<strong>i = (n - 1) &amp; hash</strong>的操作时，n的取值是至关重要的，我们都知道在HashMap中，HashMap的容量必需为<strong>2^n</strong>，那为什么必需为<strong>2^n</strong>呢？，接下来我们来分析下。</p><table><thead><tr><th>2^n</th><th>2^n（二进制）</th><th>(2^n) - 1（二进制）</th></tr></thead><tbody><tr><td>2</td><td>10</td><td>1</td></tr><tr><td>4</td><td>100</td><td>11</td></tr><tr><td>8</td><td>1000</td><td>111</td></tr><tr><td>16</td><td>10000</td><td>1111</td></tr></tbody></table><p>从上面我们可以看出，<strong>(2^n) - 1</strong>后二进制的低位都为1。那低位均为1，这样有什么作用吗？</p><p>在<strong>i = (n - 1) &amp; hash</strong> 的运算中，假设n = 6， <strong>(n - 1)</strong> 的二进制为0000 0000 0000 0000 0000 0000 0000 0<strong>101</strong>，与之进行按位与运算的就只有最后3位，即hash的最后3位可能出现的结果如下：</p><table><thead><tr><th>hash</th><th>i = 101 &amp; hash</th></tr></thead><tbody><tr><td>000</td><td>0</td></tr><tr><td>001</td><td>1</td></tr><tr><td>010</td><td>0</td></tr><tr><td>100</td><td>4</td></tr><tr><td>101</td><td>5</td></tr><tr><td>110</td><td>4</td></tr><tr><td>111</td><td>5</td></tr></tbody></table><p>从上面列子可以看出，<strong>n = 6</strong>时，出现了分布不均匀，计算不出i = 2或者3的结果，这说明了bucket2和bucket3永远为空。</p><p>接下来我们把n换成2^n，假设n = 8，<strong>(n - 1)</strong> 的二进制为0000 0000 0000 0000 0000 0000 0000 0<strong>111</strong>，与之进行按位与运算的就只有最后3位，即hash的最后3位可能出现的结果如下：</p><table><thead><tr><th>hash</th><th>i = 111 &amp; hash</th></tr></thead><tbody><tr><td>000</td><td>0</td></tr><tr><td>001</td><td>1</td></tr><tr><td>010</td><td>2</td></tr><tr><td>100</td><td>4</td></tr><tr><td>011</td><td>3</td></tr><tr><td>101</td><td>5</td></tr><tr><td>110</td><td>6</td></tr><tr><td>111</td><td>7</td></tr></tbody></table><p>我们可以看出，在n是2^n下，能计算出所有bucket的值，这说明了哈希分布较均匀，能有效降低发生哈希碰撞的概率。</p><blockquote><p>为什么进行<strong>i = (n - 1) &amp; hash</strong>操作时要<strong>n-1</strong>，这里其实也是为了减少哈希碰撞，假设不减一的话，二进制低位一定为0，进行按位与运算后依旧为0，导致最后计算出的值均为偶数，且奇数的bucket不可能存有数据，从而造成空间浪费，同时增加发生哈希碰撞的概率。假设进行减一的话，二进制低位一定为1，然后与hash进行按位与运算，低位就可能是0或者1，计算出的值就可能是奇数或者偶数，从而降低了发生哈希碰撞的概率。</p></blockquote><p><strong>2^n在进行resize()操作时，也是有妙处的。</strong></p><table><thead><tr><th></th><th>n = 16</th><th>n = 32</th></tr></thead><tbody><tr><td>hash</td><td>0100 1001 1010 0110 1001 0011 0001 0001</td><td>0100 1001 1010 0110 1001 0011 0001 0001</td></tr><tr><td>n-1</td><td>0000 0000 0000 0000 0000 0000 000<strong>0 1111</strong></td><td>0000 0000 0000 0000 0000 0000 000<strong>1 1111</strong></td></tr><tr><td>i = (n - 1) &amp; hash</td><td>0000 0000 0000 0000 0000 0000 0000 0001</td><td>0000 0000 0000 0000 0000 0000 0001 0001</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>从上面的列子可以看出，在hashMap发生resize时，<strong>i = (n - 1) &amp; hash</strong>的计算，只是多了一个最高位1，对应的hash上的值，要么是0，要么是1，假设该位为0的话，那么resize完成后，i所处的位置保持不变。假设为1的话，即i的位置是oldCap（即旧的n值） + 原位置。resize后，新位置只可能出现在这两个bucket上。从而减少resize的性能损耗。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>之所以n的取值必须为2^n，是因为这能有效的降低发生哈希碰撞的概率，且减少resize的性能损耗。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;HashMap中hash算法（扰动函数）详解&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://yoursite.com/2021/05/18/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://yoursite.com/2021/05/18/红黑树/</id>
    <published>2021-05-18T13:01:58.000Z</published>
    <updated>2021-05-18T15:47:02.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>红黑树</strong>（英语：Red–black tree）是一种<a href="https://www.hk.jwchfzu.top/baike-自平衡二叉查找树" target="_blank" rel="noopener">自平衡二叉查找树</a>，是在<a href="https://www.hk.jwchfzu.top/baike-计算机科学" target="_blank" rel="noopener">计算机科学</a>中用到的一种<a href="https://www.hk.jwchfzu.top/baike-数据结构" target="_blank" rel="noopener">数据结构</a>，典型用途是实现<a href="https://www.hk.jwchfzu.top/baike-关联数组" target="_blank" rel="noopener">关联数组</a>。它在1972年由<a href="https://www.hk.jwchfzu.top/baike-鲁道夫·贝尔" target="_blank" rel="noopener">鲁道夫·贝尔</a>发明，被称为”<strong>对称二叉B树</strong>“，它现代的名字源于Leo J. Guibas和<a href="https://www.hk.jwchfzu.top/baike-Robert_Sedgewick" target="_blank" rel="noopener">Robert Sedgewick</a>于<a href="https://www.hk.jwchfzu.top/baike-1978年" target="_blank" rel="noopener">1978年</a>写的一篇论文。红黑树的结构复杂，但它的操作有着良好的最坏情况<a href="https://www.hk.jwchfzu.top/baike-算法分析" target="_blank" rel="noopener">运行时间</a>，并且在实践中高效</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20210518232410965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="红黑树"></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>节点是红色或黑色</li><li>根是黑色</li><li>所有叶子都是黑色（叶子是NIL节点）</li><li>每个红色节点必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点）</li><li>从任一节点到其每个叶子的所有<a href="https://www.hk.jwchfzu.top/baike-道路_(图论)" target="_blank" rel="noopener">简单路径</a>都包含相同数目的黑色节点</li></ul><h2 id="自平衡操作"><a href="#自平衡操作" class="headerlink" title="自平衡操作"></a>自平衡操作</h2><ul><li>变色：节点的颜色由红变黑或者由黑变红<br><img src="https://img-blog.csdnimg.cn/20210518232455110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="左旋"><br>左旋：以某个节点为旋转节点，其右子节点变为旋转节点的父节点，右子节点的左子节点变为旋转节点的右子节点，左子节点保持不变<br><img src="https://img-blog.csdnimg.cn/20210518232523367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="右旋"><br>右旋：以某个节点为旋转节点，其左子节点变为旋转节点的父节点，左子节点的右子节点变为旋转节点的左子节点，右子节点保持不变<h2 id="插入操作的平衡调整"><a href="#插入操作的平衡调整" class="headerlink" title="插入操作的平衡调整"></a>插入操作的平衡调整</h2></li></ul><p>红黑树规定，插入的节点必须是红色的。关于插入操作的平衡调整，有两种特殊情况，非常好处理：</p><ul><li><p>如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。</p></li><li><p>如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。</p></li></ul><p>除此之外，其他情况会违背红黑树的性质，于是需要进行调整。新节点插入之后，如果红黑树的平衡被打破了，那一般会有下面3种情况：</p><blockquote><p>正在处理的节点为X丶父节点为P丶叔叔节点为S丶祖父节点为G丶Hx代表其子树的BH（黑高，如H2，即黑高为2）</p></blockquote><h4 id="CASE1：如果正在处理的节点是X，它的叔叔节点Y是红色"><a href="#CASE1：如果正在处理的节点是X，它的叔叔节点Y是红色" class="headerlink" title="CASE1：如果正在处理的节点是X，它的叔叔节点Y是红色"></a>CASE1：如果正在处理的节点是X，它的叔叔节点Y是红色</h4><p><img src="https://img-blog.csdnimg.cn/20210518232617917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>将父节点P丶叔叔节点Y的颜色都设置为黑色</li><li>将祖父节点G的颜色设置成红色</li><li>正在处理的节点X回溯至祖父节点G（正在处理的节点就是G了，继续调整）</li></ul><blockquote><p>分析：G为红色，可能违背红黑树的性质，需要继续调整（如果G为根节点，则把G的颜色设置为黑色，即满足红黑树的性质，调整结束，此时整个红黑树的BH增加1，这是唯一增加整个红黑树的BH的情形）</p></blockquote><h4 id="CASE2：如果正在处理的节点是X，它的叔叔节点Y是黑色，X是其父节点P的右子节点"><a href="#CASE2：如果正在处理的节点是X，它的叔叔节点Y是黑色，X是其父节点P的右子节点" class="headerlink" title="CASE2：如果正在处理的节点是X，它的叔叔节点Y是黑色，X是其父节点P的右子节点"></a>CASE2：如果正在处理的节点是X，它的叔叔节点Y是黑色，X是其父节点P的右子节点</h4><p><img src="https://img-blog.csdnimg.cn/20210518232654818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>围绕父节点P左旋</li><li>把X指向P（即P变成了正在处理的节点）</li><li>跳到CASE3</li></ul><blockquote><p>分析：P丶X的关系仍然违背了红黑树的性质，需要继续调整</p></blockquote><h4 id="CASE3：如果正在处理的节点是X，它的叔叔节点Y是黑色，X是其父节点P的左子节点"><a href="#CASE3：如果正在处理的节点是X，它的叔叔节点Y是黑色，X是其父节点P的左子节点" class="headerlink" title="CASE3：如果正在处理的节点是X，它的叔叔节点Y是黑色，X是其父节点P的左子节点"></a>CASE3：如果正在处理的节点是X，它的叔叔节点Y是黑色，X是其父节点P的左子节点</h4><p><img src="https://img-blog.csdnimg.cn/20210518232722344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>将父节点P的颜色设置为黑色，祖父节点G的颜色设置为红色</li><li>围绕祖父节点右旋</li><li>调整结束</li></ul><blockquote><p>分析：最后满足红黑树的性质，调整结束</p></blockquote><h2 id="删除操作的平衡调整"><a href="#删除操作的平衡调整" class="headerlink" title="删除操作的平衡调整"></a>删除操作的平衡调整</h2><p>红黑树的删除操作的平衡调整要比插入的相对难点。不过原理类似，我们仍然根据正在处理的节点与周围的节点分布特点，来进行一定规则的调整。</p><blockquote><p>正在处理的节点为X丶父节点P丶兄弟节点S丶左侄LN丶右侄RN丶Hx代表其子树的BH<br>下面正在处理的节点X均为父节点P的左孩子，如果是右孩子，则为镜像操作</p></blockquote><h4 id="CASE1：如果正在处理的节点是X，它的兄弟节点S是红色"><a href="#CASE1：如果正在处理的节点是X，它的兄弟节点S是红色" class="headerlink" title="CASE1：如果正在处理的节点是X，它的兄弟节点S是红色"></a>CASE1：如果正在处理的节点是X，它的兄弟节点S是红色</h4><p><img src="https://img-blog.csdnimg.cn/2021051823281718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>将兄弟节点的颜色设置为黑色</li><li>将父节点的颜色色泽为红色</li><li>围绕父节点P左旋，操作后LN变成新的兄弟节点</li></ul><blockquote><p>分析：X的BH比LN的BH少1，即违背了红黑树的性质，继续调整</p></blockquote><h4 id="CASE2：如果正在处理的节点是X，它的兄弟节点S丶兄弟节点的左右子节点均为黑色"><a href="#CASE2：如果正在处理的节点是X，它的兄弟节点S丶兄弟节点的左右子节点均为黑色" class="headerlink" title="CASE2：如果正在处理的节点是X，它的兄弟节点S丶兄弟节点的左右子节点均为黑色"></a>CASE2：如果正在处理的节点是X，它的兄弟节点S丶兄弟节点的左右子节点均为黑色</h4><h4 id="2-1：父节点P是黑色"><a href="#2-1：父节点P是黑色" class="headerlink" title="2-1：父节点P是黑色"></a>2-1：父节点P是黑色</h4><p><img src="https://img-blog.csdnimg.cn/20210518232942443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>将兄弟节点S的颜色设置为红色</li><li>正在处理的节点X回溯至父节点P（正在处理的节点就是P了，继续调整）</li></ul><blockquote><p>分析：调整后P的黑高减少了1，即会整个红黑树的的每个节点到达其可达叶子节点的所有路径，包含的黑色节点的数目不同，这违背了红黑树的性质，需要继续调整（若P为根节点的，则执行该步骤会引起BH的减少，这是唯一减小整个红黑树的BH）</p></blockquote><h4 id="2-2：父节点P是红色"><a href="#2-2：父节点P是红色" class="headerlink" title="2-2：父节点P是红色"></a>2-2：父节点P是红色</h4><p><img src="https://img-blog.csdnimg.cn/20210518232958789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>将兄弟节点S的颜色设置为红色</li><li>将父节点P的颜色设置为黑色</li></ul><blockquote><p>分析：在父节点没有变色前，其分析和case 2-1是一致的，父节点变色之后，P减少的BH就补回来了，即满足所有性质，调整结束</p></blockquote><h4 id="CASE3：如果正在处理的节点是X，它的兄弟节点S是黑色，S的左子节点LN为红色，右子节点RN为黑色"><a href="#CASE3：如果正在处理的节点是X，它的兄弟节点S是黑色，S的左子节点LN为红色，右子节点RN为黑色" class="headerlink" title="CASE3：如果正在处理的节点是X，它的兄弟节点S是黑色，S的左子节点LN为红色，右子节点RN为黑色"></a>CASE3：如果正在处理的节点是X，它的兄弟节点S是黑色，S的左子节点LN为红色，右子节点RN为黑色</h4><p><img src="https://img-blog.csdnimg.cn/20210518233031953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>将左侄节点LN的颜色设置为黑色</li><li>将兄弟节点S的颜色设置为红色</li><li>围绕兄弟节点S右旋</li><li>S指向LN</li><li>跳到CASE4</li></ul><blockquote><p>分析：X的BH仍然比LN的BH少1，即继续调整</p></blockquote><h4 id="CASE4：如果正在处理的节点是X，它的兄弟节点S是黑色，父节点P可红可黑，S的右子节点RN为黑色"><a href="#CASE4：如果正在处理的节点是X，它的兄弟节点S是黑色，父节点P可红可黑，S的右子节点RN为黑色" class="headerlink" title="CASE4：如果正在处理的节点是X，它的兄弟节点S是黑色，父节点P可红可黑，S的右子节点RN为黑色"></a>CASE4：如果正在处理的节点是X，它的兄弟节点S是黑色，父节点P可红可黑，S的右子节点RN为黑色</h4><h4 id="4-1：LN为红色"><a href="#4-1：LN为红色" class="headerlink" title="4-1：LN为红色"></a>4-1：LN为红色</h4><p><img src="https://img-blog.csdnimg.cn/20210518233058365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>将兄弟节点S的颜色设置为与父节点P的颜色相同</li><li>将父节点P的颜色设置为黑色</li><li>将S的右子节点RN的颜色设置为黑</li><li>围绕父节点P左旋</li><li>X指向根节点</li></ul><blockquote><p>分析：调整后满足红黑树的性质，调整结束</p></blockquote><h4 id="4-2：LN为黑色"><a href="#4-2：LN为黑色" class="headerlink" title="4-2：LN为黑色"></a>4-2：LN为黑色</h4><p><img src="https://img-blog.csdnimg.cn/20210518233142433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>将兄弟节点S的颜色设置为与父节点P的颜色相同</li><li>将父节点P的颜色设置为黑色</li><li>将S的右子节点RN的颜色设置为黑</li><li>围绕父节点P左旋</li><li>X指向根节点</li></ul><blockquote><p>分析：调整后满足红黑树的性质，调整结束</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;红黑树&lt;/strong&gt;（英语：Red–black tree）是一种&lt;a href=&quot;https://www.hk.jwchfzu.top/baike-自平衡二叉查找树&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自平衡二叉查找树&lt;/a&gt;，是在&lt;a href=&quot;https://www.hk.jwchfzu.top/baike-计算机科学&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;计算机科学&lt;/a&gt;中用到的一种&lt;a href=&quot;https://www.hk.jwchfzu.top/baike-数据结构&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据结构&lt;/a&gt;，典型用途是实现&lt;a href=&quot;https://www.hk.jwchfzu.top/baike-关联数组&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关联数组&lt;/a&gt;。它在1972年由&lt;a href=&quot;https://www.hk.jwchfzu.top/baike-鲁道夫·贝尔&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鲁道夫·贝尔&lt;/a&gt;发明，被称为”&lt;strong&gt;对称二叉B树&lt;/strong&gt;“，它现代的名字源于Leo J. Guibas和&lt;a href=&quot;https://www.hk.jwchfzu.top/baike-Robert_Sedgewick&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Robert Sedgewick&lt;/a&gt;于&lt;a href=&quot;https://www.hk.jwchfzu.top/baike-1978年&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1978年&lt;/a&gt;写的一篇论文。红黑树的结构复杂，但它的操作有着良好的最坏情况&lt;a href=&quot;https://www.hk.jwchfzu.top/baike-算法分析&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;运行时间&lt;/a&gt;，并且在实践中高效&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码解析</title>
    <link href="http://yoursite.com/2021/05/13/ThreadLocal%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2021/05/13/ThreadLocal源码/</id>
    <published>2021-05-13T13:01:58.000Z</published>
    <updated>2021-05-13T14:33:26.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ThreadLocal，即线程变量，用于存放本次线程的常用变量，且这些变量是线程隔离的。ThreadLocal为变量在每个线程中都创建了一个副本。ThreadLocal底层的存储结构是ThreadLocalLocalMap。</p><a id="more"></a><h4 id="ThreadLocalMap源码"><a href="#ThreadLocalMap源码" class="headerlink" title="ThreadLocalMap源码"></a>ThreadLocalMap源码</h4><p>先简单的说下ThreadLocalMap的结构，ThreadLocalMap的结构类似HashMap，底层的结构是用一个Entry数组维护，Entry结构就是key-value，key为当前ThreadLocal对象，value为具体要存放的值。接下来看看具体的源码实现。</p><blockquote><p>本文只讲常用且较为重要的相关源码，其他的源码，有兴趣的读者可以自行阅读。</p></blockquote><h5 id="类成员变量与相应方法"><a href="#类成员变量与相应方法" class="headerlink" title="类成员变量与相应方法"></a>类成员变量与相应方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 初始容量为16，必须为2的幂</span><br><span class="line"> */</span><br><span class="line">private static final int INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Entry表，大小必须为2的幂</span><br><span class="line"> */</span><br><span class="line">private Entry[] table;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Entry表里的个数</span><br><span class="line"> */</span><br><span class="line">private int size = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 重新分配表大小的阈值，默认为0</span><br><span class="line"> */</span><br><span class="line">private int threshold; </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设置resize阈值以维持最坏2/3的装载因子</span><br><span class="line"> */</span><br><span class="line">private void setThreshold(int len) &#123;</span><br><span class="line">    threshold = len * 2 / 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 下一个索引</span><br><span class="line"> */</span><br><span class="line">private static int nextIndex(int i, int len) &#123;</span><br><span class="line">    return ((i + 1 &lt; len) ? i + 1 : 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 上一个索引</span><br><span class="line"> */</span><br><span class="line">private static int prevIndex(int i, int len) &#123;</span><br><span class="line">    return ((i - 1 &gt;= 0) ? i - 1 : len - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Entry的结构</span><br><span class="line"> */</span><br><span class="line">static class Entry extends WeakReference&lt;java.lang.ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(java.lang.ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        super(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 构造一个最初包含firstKey和firstValue的threadLocalMap。</span><br><span class="line"> * ThreadLocalMap是惰性构造的，所以只有当至少往里面放一个元素的时候才会构建它</span><br><span class="line"> */</span><br><span class="line">ThreadLocalMap(java.lang.ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    // 初始化一个大小为16的table数组</span><br><span class="line">    table = new Entry[INITIAL_CAPACITY];</span><br><span class="line">    // 计算出firstKey所在的slot的位置</span><br><span class="line">    int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">    // 初始化该entry</span><br><span class="line">    table[i] = new Entry(firstKey, firstValue);</span><br><span class="line">    // 设置entry表的大小为1</span><br><span class="line">    size = 1;</span><br><span class="line">    // 设置扩容阈值</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取entry</span><br><span class="line"> */</span><br><span class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    // 如果找到key，则返回</span><br><span class="line">    if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">        return e;</span><br><span class="line">    // 如果找不到，则调用getEntryAfterMiss</span><br><span class="line">    else</span><br><span class="line">        return getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 这里先说明下，由于ThreadLocalMap是使用了线性探测来解决哈希冲突的。</span><br><span class="line"> * 线性探测的原理就是如果发生的哈希冲突，即从当前的位置向后遍历，</span><br><span class="line"> * 找到下一个空的slot后插入进去。</span><br><span class="line"> * </span><br><span class="line"> * 可能发生了哈希冲突，从i位置，向后扫描可能能取到想要的entry</span><br><span class="line"> */</span><br><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    </span><br><span class="line">    while (e != null) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        // 如果找到key，则返回</span><br><span class="line">        if (k == key)</span><br><span class="line">            return e;</span><br><span class="line">        // 如果为空，则说明该threadLocal已经被回收，调用expungeStaleEntry清理掉失效的entry</span><br><span class="line">        if (k == null)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        // 这里说明可能发生了哈希冲突，所以继续遍历下去</span><br><span class="line">        else</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设置key和value</span><br><span class="line"> */</span><br><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    // 通过hash，找到所在的slot的位置</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">    // 判断并解决哈希冲突</span><br><span class="line">    for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        // 存在，则覆盖value</span><br><span class="line">        if (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 不存在，说明该key被垃圾回收了，调用replaceStaleEntry</span><br><span class="line">        if (k == null) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //这里说明tab[i] == null，直接插入</span><br><span class="line">    tab[i] = new Entry(key, value);</span><br><span class="line">    int sz = ++size;</span><br><span class="line">    //如果没清理出去key，且当前table大小已经超过阈值，则rehash</span><br><span class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过key删除entry</span><br><span class="line"> */</span><br><span class="line">private void remove(ThreadLocal key) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">    for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        //找到对应的entry，清理掉</span><br><span class="line">        if (e.get() == key) &#123;</span><br><span class="line">        // 显式断开弱引用</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 先向前扫描，找到最前的一个失效的slot，如果找到的话，就以该位置作为清理的起点，反着就以i作起点。然后做清理</span><br><span class="line"> */</span><br><span class="line">private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,</span><br><span class="line">                               int staleSlot) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    int slotToExpunge = staleSlot;</span><br><span class="line">    // 向前扫描，查找最前的失效的slot</span><br><span class="line">    for (int i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != null;</span><br><span class="line">         i = prevIndex(i, len)) &#123;</span><br><span class="line">        if (e.get() == null) &#123;</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 向后扫描</span><br><span class="line">    for (int i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != null;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        // 找到key，将其与失效的slot替换</span><br><span class="line">        if (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            // 如果前面没有找到失效的slot，则用当前i作为清理起点</span><br><span class="line">            if (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            // 从slotToExpunge位置开始做清理</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果当前的key已经失效，并且前面没有找到失效的slot，则更新slotToExpunge为当前i</span><br><span class="line">        if (k == null &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果key在table中不存在，则在将新entry放入slot中</span><br><span class="line">    tab[staleSlot].value = null;</span><br><span class="line">    tab[staleSlot] = new Entry(key, value);</span><br><span class="line"></span><br><span class="line">    // 在扫描中如果发现任何失效的slot，则清理</span><br><span class="line">    if (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从staleSlot的位置开始对失效的entry进行回收，过程还会对非失效的entry进行rehash</span><br><span class="line"> */</span><br><span class="line">private int expungeStaleEntry(int staleSlot) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line"></span><br><span class="line">    // 显式设置value为null，断开强引用</span><br><span class="line">    tab[staleSlot].value = null;</span><br><span class="line">    // 显式设置entry为null</span><br><span class="line">    tab[staleSlot] = null;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    Entry e;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        // 清理已被回收threadLocal的entry</span><br><span class="line">        if (k == null) &#123;</span><br><span class="line">            e.value = null;</span><br><span class="line">            tab[i] = null;</span><br><span class="line">            size--;</span><br><span class="line">        // 如果没有被回收，则rehash</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int h = k.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">            if (h != i) &#123;</span><br><span class="line">                tab[i] = null;</span><br><span class="line">                </span><br><span class="line">                // Unlike Knuth 6.4 Algorithm R, we must scan until</span><br><span class="line">                // null because multiple entries could have been stale.</span><br><span class="line">                while (tab[h] != null) &#123;</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                &#125;</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回staleSlot之后的第一个空slot索引</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 进行一定次数的循环，从i的位置开始对失效的entry进行清理，n &gt;&gt;&gt;= 1，说明了开始会进行log2(n)次的</span><br><span class="line"> * 循环，如果没有发现失效的slot，函数就结束了，但是发现了失效的slot的话，会将n设置为table的长度，</span><br><span class="line"> * 再做清理后再从下个空的slot继续扫描。</span><br><span class="line"> */</span><br><span class="line">private boolean cleanSomeSlots(int i, int n) &#123;</span><br><span class="line">    boolean removed = false;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    do &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        if (e != null &amp;&amp; e.get() == null) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = true;</span><br><span class="line">            // 清理</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((n &gt;&gt;&gt;= 1) != 0);</span><br><span class="line">    return removed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * rehash操作</span><br><span class="line"> */</span><br><span class="line">private void rehash() &#123;</span><br><span class="line">    // 做次清理</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">     // 上面做了次清理，size可能变小了，判断是否不足以缩小表的大小，如果是的话，则将表的大小增加一倍</span><br><span class="line">    if (size &gt;= threshold - threshold / 4) &#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 扩容操作，table的容量必须为2的幂</span><br><span class="line"> */</span><br><span class="line">private void resize() &#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    int oldLen = oldTab.length;</span><br><span class="line">    int newLen = oldLen * 2;</span><br><span class="line">    Entry[] newTab = new Entry[newLen];</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    for (int j = 0; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            if (k == null) &#123;</span><br><span class="line">            // 帮助GC</span><br><span class="line">                e.value = null; </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int h = k.threadLocalHashCode &amp; (newLen - 1);</span><br><span class="line">                while (newTab[h] != null) &#123;</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                &#125;</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 扫描整个entry表，做清理</span><br><span class="line"> */</span><br><span class="line">private void expungeStaleEntries() &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        if (e != null &amp;&amp; e.get() == null) &#123;</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> ThreadLocal其实就是在ThreadLocalMap上再做简单的封装，这里就不讲述了。</p></blockquote><h3 id="ThreadLocalMap的一些问题"><a href="#ThreadLocalMap的一些问题" class="headerlink" title="ThreadLocalMap的一些问题"></a>ThreadLocalMap的一些问题</h3><h4 id="1丶Entry的key为什么要用弱引用"><a href="#1丶Entry的key为什么要用弱引用" class="headerlink" title="1丶Entry的key为什么要用弱引用"></a>1丶Entry的key为什么要用弱引用</h4><p>在官方ThreadLocalMap的源码注释里面已经提到了就是帮助GC的回收</p><p>当某个ThreadLocal实例没有任何的强引用指向它时，ThreadLocal将会被gc回收，那么在ThreadLocalMap里对应的Entry的key会失效。</p><h4 id="2丶Entry的value是如何回收"><a href="#2丶Entry的value是如何回收" class="headerlink" title="2丶Entry的value是如何回收"></a>2丶Entry的value是如何回收</h4><p>从上面的源码可以看出，每次的操作（get set等）都会去扫描失效的entry并清理，value也是在这时候进行处理的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;ThreadLocal，即线程变量，用于存放本次线程的常用变量，且这些变量是线程隔离的。ThreadLocal为变量在每个线程中都创建了一个副本。ThreadLocal底层的存储结构是ThreadLocalLocalMap。&lt;/p&gt;
    
    </summary>
    
      <category term="线程" scheme="http://yoursite.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>栈帧结构</title>
    <link href="http://yoursite.com/2021/04/15/%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2021/04/15/栈帧结构/</id>
    <published>2021-04-15T15:01:58.000Z</published>
    <updated>2021-04-15T20:25:25.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>运行时栈帧结构</p><a id="more"></a><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表丶操作数栈丶动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧。与当前栈帧相关联的方法，称为当前方法。</p><p><img src="https://img-blog.csdnimg.cn/20210416042457148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="栈帧结构"></p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。容量的最小单位为变量槽（Variable Slot，简称Slot）。</p><p>虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小，只是很有导向性地说到每个Slot都应该能存放一个boolean丶byte丶char丶short丶int丶float丶reference或者returnAddress类型数据。这8种数据类型，都可以使用32位以内的物理内存来存放。也就是说一个Slot可以存放一个32位以内的数据类型。对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。Java语言中明确的64位的数据类型只有long和double两种。</p><blockquote><p>值得一提的是，这里把long和double数据类型分割存储的做法与“long和double的非原子性协定”中把一次long和double数据类型读写分割为两次32位读写的做法有些类型。不过由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问题。</p></blockquote><blockquote><p>Slot的长度可以随着处理器丶操作系统或者虚拟机的不同而发生变化。只要保证即使在64为虚拟机中使用了64位的物理内存空间去实现一个Slot，虚拟机仍要使用对齐和补白的手段让Slot在外观看起来与32位虚拟机中的一致。</p></blockquote><p>虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的Slot数量。如果访问的是32位数据类型的变量，索引n就代表了使用第n个Slot。如果是64位数据类型的变量，则说明会同时使用n和n+1两个Slot。</p><blockquote><p>对于存放一个64位数据类型的两个相邻的Slot，不允许采用任何方式单独访问其中一个，如果遇到进行这个操作的字节码序列，虚拟机应该在类加载的校验阶段抛出异常。</p></blockquote><p>在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非static的方法），那局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。</p><p>局部变量表中的Slot是可以重用的，是为了尽可能节省栈帧空间，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。不过，这样的设计会伴随一些额外的副作用，如直接影响到系统的垃圾收集行为。</p><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</p><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。</p><blockquote><p>另外，在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但在大多虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，无须进行额外的参数复制传递。</p></blockquote><h2 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h2><p>每一个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</p><h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>当一个方法开始执行后，只有两种方法可以退出这个方法。第一种方法是执行引擎遇到任何一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口。另外一种退出方法是，在方法执行过程中遇到异常，并且这个异常没有在方法体内得到处理，就会导致方法退出，这种退出方法的方式称为异常完成出口。</p><blockquote><p>无论采用哪种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。一般来说，方法正常退出时，调用者的PC计数器可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p></blockquote><p>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;运行时栈帧结构&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="http://yoursite.com/2021/04/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2021/04/15/虚拟机类加载机制/</id>
    <published>2021-04-15T14:01:58.000Z</published>
    <updated>2021-04-15T14:20:02.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虚拟机类加载机制</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验丶转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><a id="more"></a><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载丶验证丶准备丶解析丶初始化丶使用和卸载7个阶段。其中验证丶准备丶解析3个部分统称为连接。</p><p><img src="https://img-blog.csdnimg.cn/20210415221243368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="类加载的时机"></p><p>Java虚拟机规范中并没有对“加载“阶段进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载丶验证丶准备自然需要在此之前开始）：</p><ol><li>遇到new丶getstatic丶putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候丶读取或设置一个类的静态字段的时候，以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic丶REF_putStatic丶REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ol><p>这5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。</p><p>被动引用列子一：</p><p>通过子类引用父类的静态字段，不会导致子类初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package org.petsch.clazz;</span><br><span class="line"></span><br><span class="line">public class SuperClass &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;SuperClass init!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int value = 123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SubClass extends SuperClass&#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;SubClass init!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class NotInitialization &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码执行之后，只会输出“SuperClass init!”，而不会输出“SubClass init!”。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要触发子类的加载和验证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。对于Hotspot虚拟机来说，可通过-XX:+TraceClassLoading参数观察到此操作会导致子类的加载。</p></blockquote><p>被动引用列子二：</p><p>通过数组定义来引用类，不会触发此类的初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package org.petsch.clazz;</span><br><span class="line"></span><br><span class="line">public class SuperClass &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;SuperClass init!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int value = 123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SubClass extends SuperClass&#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;SubClass init!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class NotInitialization &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SuperClass[] sca = new SuperClass[10];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码执行之后，发现没有输出“SuperClass init!”，说明并没有触发类org.petsch.clazz.SuperClass的初始化阶段，但是会触发另外一个名为“[Lorg.petsch.clazz.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是一个合法的类名称，它是由虚拟机自动生成的丶直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。这个类代表了一个元素类型为org.petsch.clazz.SuperClass的一维数组，数组中应有的属性和方法都实现在这个类里。</p></blockquote><p>被动引用列子三：</p><p>常量在编译阶段会存入调用类的常量池，本质上并灭有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package org.petsch.clazz;</span><br><span class="line"></span><br><span class="line">public class ConstClass &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;ConstClass init!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final String HELLO_WORLD = &quot;hello world&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class NotInitialization &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(ConstClass.HELLO_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码执行之后，没有输出“ConstClass init!”，这是因为虽然在Java源码中引用了ConstClass类中的常量HELLO_WORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值“hello world”存储到了NotInitialization类的常量池中，以后NotInitialization对常量ConstClass.HELLO_WORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。</p></blockquote><p>接口的加载过程与类加载过程稍有一些不同，接口也有初始化过程，这点与类是一致的，真正有所区别的是前面讲述的5种“有且仅有”需要开始初始化场景中的第3种，当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父类接口全部都完成了初始化，只有在真正使用到父类接口的时候（如引用接口中定义的常量）才会初始化。</p><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>Java虚拟机中类加载的全过程，也就是加载丶验证丶准备丶解析和初始化这5个阶段执行的具体动作。</p><h3 id="1丶加载"><a href="#1丶加载" class="headerlink" title="1丶加载"></a>1丶加载</h3><p>“加载”就是类加载过程的一个阶段，在加载阶段，虚拟机需要完成以下3件事情：</p><ul><li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p></li></ul><blockquote><p>数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。但是数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数组类创建过程就遵循以下规则：</p><ul><li>如果数组的组件类型（Component Type，指的是数组去掉了一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的加载器的类名称空间上被标识。</li><li>如果数组的组件类型不是引用类型，Java虚拟机将会把数组标记为与引导类加载器关联。</li><li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。</li></ul></blockquote><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的这些类型数据的外部接口。</p><blockquote><p>加载阶段与连接阶段的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p></blockquote><h3 id="2丶验证"><a href="#2丶验证" class="headerlink" title="2丶验证"></a>2丶验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符号当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成下面4个阶段的验证动作：</p><ul><li><p>文件格式验证</p><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。该阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，这一阶段可能包括下面这些验证点：</p><ul><li>是否以魔数开头。</li><li>主次版本号是否在当前虚拟机处理范围之内。</li><li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li><li>指向常量的各种索引值中是否有指向不存在的常量或者不符合类型的常量。</li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。</li><li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li><li>…</li></ul></li><li><p>元数据验证</p><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。该阶段的验证是基于方法区的存储结构进行的，不会再直接操作字节流。这个阶段可能包括的验证点如下：</p><ul><li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li><li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段丶方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载）</li><li>…</li></ul></li><li><p>字节码验证</p><p>第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的，丶符合逻辑的。这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：</p><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作数栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li><li>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系丶完全不相干的一个数据类型，则是危险和不合法的。</li><li>…</li></ul><blockquote><p>由于数据流验证的高复杂性，虚拟机设计团队为了避免过多的时间消耗在字节码验证阶段，在JDK 1.6之后的Javac编译器和Java虚拟机中进行了一项优化，给方法体的Code属性的属性表中增加了一项名为“StackMapTable”的属性，这项属性描述了方法所有基本块（Basic Block，按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节码验证期间，就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。</p><p>在JDK 1.6的HotSpot虚拟机中提供了-XX:-UseSplitVerifier选项来关闭这项优化，或者使用参数-XX:+FailOverToOldVerifier要求在类型校验失败的时候退回到旧的类型推导方法进行校验。而在JDK 1.7之后，对于主版本号大于50的Class文件，使用类型检查来完成数据流分析校验则是唯一的选择，不允许再退回到类型推导的校验方法。</p></blockquote></li><li><p>符号引用验证</p><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段”解析”阶段中发生。目的是确保解析动作能正常执行。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容：</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>在指定类中是否存在符号方法的字段描述符以及简单名称所描述的方法和字段。</li><li>符号引用中的类丶字段丶方法的访问性（private丶protected丶public丶default）是否可被当前类访问。</li><li>…</li></ul></li></ul><blockquote><p>对于虚拟机的类加载机制来说，验证阶段是一个非常重要的丶但不是一定必要的阶段，如果所运行的全部代码都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p></blockquote><h3 id="3丶准备"><a href="#3丶准备" class="headerlink" title="3丶准备"></a>3丶准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值通常情况下是数据类型的零值。假设一个类变量的定义为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static int value = 123;</span><br></pre></td></tr></table></figure><p>变量value在准备阶段过后的初始值为0，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。</clinit></p><p>特殊情况下：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化ConstantValue属性所指定的值，假设类变量的定义为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final int value  = 123；</span><br></pre></td></tr></table></figure><p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p><h3 id="4丶解析"><a href="#4丶解析" class="headerlink" title="4丶解析"></a>4丶解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><ul><li>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件各式中。</li><li>直接引用：直接引用可以是直接指向目标的指针丶相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</li></ul><blockquote><p>虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield和putstatic这16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p><p>对同一个符号引用进行多次解析请求是很常见的事情，除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直成功；同样的，如果第一次解析失败了，那么其他指令对这个符号的解析请求也应该收到相同的异常。对于invokedynamic指令，上面规则则不成立。当碰到某个前面已经由invokedynamic指令触发过解析的符号引用时，并不意味着这个解析结果对于其他invokedynamic指令也同样生效。因为invokedynamic指令的目的本来就是用于动态语言支持（目前仅使用Java语言不会生成这条字节码指令），它所对应的引用称为“动态调用点限定符”（Dynamic Call Site Specifier），这里“动态”的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。</p></blockquote><p>解析动作主要针对类或接口丶字段丶类方法丶接口方法丶方法类型丶方法句柄和调用点限定符7类符号引用进行的。下面将讲解前面4种引用的解析过程。</p><h4 id="1丶类或接口的解析"><a href="#1丶类或接口的解析" class="headerlink" title="1丶类或接口的解析"></a>1丶类或接口的解析</h4><p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或者接口C的直接引用，那虚拟机完成整个解析的过程需要以下3个步骤：</p><ol><li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证丶字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。</li><li>如果C是一个数组类型，并且数组的1元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载得到元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。</li><li>如果上面的步骤没哟出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确定D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IIIegalAccessError异常。</li></ol><h4 id="2丶字段解析"><a href="#2丶字段解析" class="headerlink" title="2丶字段解析"></a>2丶字段解析</h4><p>要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索。</p><ol><li>如果C本身就包含了简单名称和字段描述都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li></ol><p>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IIIegalAccessError异常。</p><blockquote><p>在实际应用中，虚拟机的编译器实现可能会比上述规范要求的更加严格一些，如果有一个同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器将可能拒绝编译。</p></blockquote><h4 id="3丶类方法解析"><a href="#3丶类方法解析" class="headerlink" title="3丶类方法解析"></a>3丶类方法解析</h4><p>类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。</p><ol><li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li><li>如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在类C的父类的接口列表及它们的接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这是查找结束，抛出java.lang.AbstractMethodError异常。</li><li>否则，宣告方法查找失败，抛出java.lang.IIIegalAccessError异常。</li></ol><p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IIIegalAccessError异常。</p><h4 id="4丶接口方法解析"><a href="#4丶接口方法解析" class="headerlink" title="4丶接口方法解析"></a>4丶接口方法解析</h4><p>接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。</p><ol><li>与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li><li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在接口C的父接口中递归查找，直到java.lang.Object类为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li></ol><p>由于接口中的所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang.NoSuchMethodError异常。</p><h3 id="5丶初始化"><a href="#5丶初始化" class="headerlink" title="5丶初始化"></a>5丶初始化</h3><p>类初始化阶段是类加载过程的最后一步，到了该阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></p><ul><li><p><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</clinit></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        i = 0;                      // 给变量赋值可以正常编译通过</span><br><span class="line">        System.out.println(i);      // 编译器会提示“非法向前引用”</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int i = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><clinit>()方法与类的构造函数（或者说实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object。</clinit></clinit></clinit></init></clinit></p></li><li><p>由于父类的<clinit>()方法先执行，也就是意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</clinit></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static class Parent&#123;</span><br><span class="line">    public static int A = 1;</span><br><span class="line">        </span><br><span class="line">    static &#123;</span><br><span class="line">        A = 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Sub extends Parent&#123;</span><br><span class="line">    public static int B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(Sub.B);    // 输出的值为2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</clinit></clinit></p></li><li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</clinit></clinit></clinit></clinit></p></li><li><p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁丶同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</clinit></clinit></clinit></clinit></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static class DeadLoopClass&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        if(true)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot;init DeadLoopClass&quot;);</span><br><span class="line">            while (true)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Runnable script = new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot;start&quot;);</span><br><span class="line"></span><br><span class="line">            DeadLoopClass dlc = new DeadLoopClass();</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot;run over&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Thread thread1 = new Thread(script);</span><br><span class="line">    Thread thread2 = new Thread(script);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下，即一条线程在死循环以模拟长时间操作，另外一条线程在阻塞等待。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread[Thread-0,5,main]start</span><br><span class="line">Thread[Thread-1,5,main]start</span><br><span class="line">Thread[Thread-0,5,main]init DeadLoopClass</span><br></pre></td></tr></table></figure></li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这个两个类就必定不相等。</p><blockquote><p>这里所指的“相等”，包括代表类的Class对象的equals()方法丶isAssignableFrom()方法丶isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。</p></blockquote><p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader。</p><p>从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器。</p><ul><li>启动类加载器（Bootstrap ClassLoader）：这个类加载器负责将存放在<java_home>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。</java_home></li><li>扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<java_home>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</java_home></li><li>应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也它称为系统类加载器。它负责加载用户类路径（ClassPath）上所制定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><h3 id="类加载器之间的关系"><a href="#类加载器之间的关系" class="headerlink" title="类加载器之间的关系"></a>类加载器之间的关系</h3><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p><img src="https://img-blog.csdnimg.cn/20210415221334463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="双亲委派模型"></p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现的，而是使用组合关系来复用父加载器的代码。</p><blockquote><p>双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。</p></blockquote><p>工作过程：如果一个类加载器收到了加载器的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载器请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围没有找到所需的类）时，子加载器才会尝试自己去加载。</p><blockquote><p>好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的化，如果用户自己编写一个称为java.lang.Object的类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。</p></blockquote><p>源码如下：</p><p>先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载器加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">            // First, check if the class has already been loaded</span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                long t0 = System.nanoTime();</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (parent != null) &#123;</span><br><span class="line">                        c = parent.loadClass(name, false);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    // ClassNotFoundException thrown if class not found</span><br><span class="line">                    // from the non-null parent class loader</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (c == null) &#123;</span><br><span class="line">                    // If still not found, then invoke findClass in order</span><br><span class="line">                    // to find the class.</span><br><span class="line">                    long t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    // this is the defining class loader; record the stats</span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2发布之前。由于双亲委派模型在JDK 1.2之后才被引入，而类加载器和抽象类java.lang. ClassLoader则在JDK 1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK 1.2之后的java.lang.ClassLoader添加了一个新的protected方法findClass()，在此之前，用户去继承java. lang.ClassLoader的唯一目的就是为了重写loadClass()方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。双亲委派的具体逻辑就实现在这个方法之中，JDK 1.2之后已不提倡用户再去覆盖loadClass()方法，而应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里如果父类加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。</p><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，如果基础类又要调用回用户的代码呢？一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK 1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI，Service Provider Interface）的代码，但启动类加载器不可能“认识”这些代码啊！那该怎么办？为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoaser()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>有了线程上下文类加载器，就可以做一些“舞弊”的事情了，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。</p><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换（HotSwap）、模块热部署（Hot Deployment）等，说白了就是希望应用程序能像我们的计算机外设那样，接上鼠标、U盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用停机也不用重启。对于个人计算机来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是企业级软件开发者具有很大的吸引力。</p><p>在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p><ol><li>将以java.*开头的类委派给父类加载器加载。</li><li>否则，将委派列表名单内的类委派给父类加载器加载。</li><li>否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。</li><li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li><li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li><li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li><li>否则，类查找失败。上面的查找顺序中只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;虚拟机类加载机制&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验丶转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java Class文件详解</title>
    <link href="http://yoursite.com/2021/03/11/Java%20Class%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2021/03/11/Java Class文件详解/</id>
    <published>2021-03-11T14:01:58.000Z</published>
    <updated>2021-03-11T16:28:34.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java Class文件详解</p><a id="more"></a><h1 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h1><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列才Class文件之中，中间没有添加任何分隔符。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分隔成若干个8位字节进行存储。</p><p>根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两个数据类型：无符号数和表。</p><p><strong>无符号数</strong>：属于基本的数据类型，以u1丶u2丶u4丶u8分别代表1个字节丶2个字节丶4个字节丶8个字节的无符号数，无符号数可以用来描述数字丶索引引用丶数量值或者按照UTF-8编码构成字符串值。</p><p><strong>表</strong>：由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质就是一张表。</p><h1 id="Class文件的数据项构成"><a href="#Class文件的数据项构成" class="headerlink" title="Class文件的数据项构成"></a><strong>Class文件的数据项构成</strong></h1><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>constant_pool_count-1</td></tr><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td>1</td></tr><tr><td>methods_info</td><td>methods</td><td>methods_count</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attributes_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><p><strong>案例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.petsch.clazz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用十六进制打开Class文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cafe babe <span class="number">0000</span> <span class="number">0034</span> <span class="number">0013</span> <span class="number">0</span>a00 <span class="number">0400</span> <span class="number">0f</span>09</span><br><span class="line"><span class="number">0003</span> <span class="number">0010</span> <span class="number">0700</span> <span class="number">1107</span> <span class="number">0012</span> <span class="number">0100</span> <span class="number">016</span>d <span class="number">0100</span></span><br><span class="line"><span class="number">0149</span> <span class="number">0100</span> <span class="number">063</span>c <span class="number">696</span>e <span class="number">6974</span> <span class="number">3e01</span> <span class="number">0003</span> <span class="number">2829</span></span><br><span class="line"><span class="number">5601</span> <span class="number">0004</span> <span class="number">436f</span> <span class="number">6465</span> <span class="number">0100</span> <span class="number">0f</span>4c <span class="number">696</span>e <span class="number">654</span>e</span><br><span class="line"><span class="number">756</span>d <span class="number">6265</span> <span class="number">7254</span> <span class="number">6162</span> <span class="number">6</span>c65 <span class="number">0100</span> <span class="number">0369</span> <span class="number">6e63</span></span><br><span class="line"><span class="number">0100</span> <span class="number">0328</span> <span class="number">2949</span> <span class="number">0100</span> <span class="number">0</span>a53 <span class="number">6f</span>75 <span class="number">7263</span> <span class="number">6546</span></span><br><span class="line"><span class="number">696</span>c <span class="number">6501</span> <span class="number">0009</span> <span class="number">5465</span> <span class="number">7374</span> <span class="number">2e6</span>a <span class="number">6176</span> <span class="number">610</span>c</span><br><span class="line"><span class="number">0007</span> <span class="number">0008</span> <span class="number">0</span>c00 <span class="number">0500</span> <span class="number">0601</span> <span class="number">0015</span> <span class="number">6f</span>72 <span class="number">672f</span></span><br><span class="line"><span class="number">7065</span> <span class="number">7473</span> <span class="number">6368</span> <span class="number">2f</span>63 <span class="number">6</span>c61 <span class="number">7</span>a7a <span class="number">2f</span>54 <span class="number">6573</span></span><br><span class="line"><span class="number">7401</span> <span class="number">0010</span> <span class="number">6</span>a61 <span class="number">7661</span> <span class="number">2f</span>6c <span class="number">616</span>e <span class="number">672f</span> <span class="number">4f</span>62</span><br><span class="line"><span class="number">6</span>a65 <span class="number">6374</span> <span class="number">0021</span> <span class="number">0003</span> <span class="number">0004</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0002</span></span><br><span class="line"><span class="number">0005</span> <span class="number">0006</span> <span class="number">0000</span> <span class="number">0002</span> <span class="number">0001</span> <span class="number">0007</span> <span class="number">0008</span> <span class="number">0001</span></span><br><span class="line"><span class="number">0009</span> <span class="number">0000</span> <span class="number">001</span>d <span class="number">0001</span> <span class="number">0001</span> <span class="number">0000</span> <span class="number">0005</span> <span class="number">2</span>ab7</span><br><span class="line"><span class="number">0001</span> b100 <span class="number">0000</span> <span class="number">0100</span> <span class="number">0</span>a00 <span class="number">0000</span> <span class="number">0600</span> <span class="number">0100</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0300</span> <span class="number">0100</span> <span class="number">0b00</span> <span class="number">0</span>c00 <span class="number">0100</span> <span class="number">0900</span> <span class="number">0000</span></span><br><span class="line"><span class="number">1f</span>00 <span class="number">0200</span> <span class="number">0100</span> <span class="number">0000</span> <span class="number">072</span>a b400 <span class="number">0204</span> <span class="number">60</span>ac</span><br><span class="line"><span class="number">0000</span> <span class="number">0001</span> <span class="number">000</span>a <span class="number">0000</span> <span class="number">0006</span> <span class="number">0001</span> <span class="number">0000</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0001</span> <span class="number">000</span>d <span class="number">0000</span> <span class="number">0002</span> <span class="number">000</span>e</span><br></pre></td></tr></table></figure><h2 id="魔数："><a href="#魔数：" class="headerlink" title="魔数："></a><strong>魔数</strong>：</h2><p>每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。（值为：0xCAFEBABE 咖啡宝贝）</p><blockquote><p><font color="red"><strong>cafe babe</strong></font> 0000 0034 0013 0a00 0400 0f09</p></blockquote><h2 id="版本号："><a href="#版本号：" class="headerlink" title="版本号："></a><strong>版本号</strong>：</h2><p>紧接着魔数后面的是Class文件的版本号，第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。</p><blockquote><p>cafe babe <font color="red"><strong>0000 0034</strong></font> 0013 0a00 0400 0f09<br><strong>0x0034转十进制为52，代表当前使用的JDK 1.8版本。</strong></p></blockquote><blockquote><p>注：Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1，高版本的JDK能向下兼容，但是不能运行以后版本的Class文件。</p></blockquote><h2 id="常量池："><a href="#常量池：" class="headerlink" title="常量池："></a><strong>常量池</strong>：</h2><p>紧接着是常量池入口。常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项之一，同时它还是在Class文件中第一个出现的表类型数据项目。</p><ul><li><strong>常量池容量计数值（constant_pool_count）</strong>：由于常量池中常量的数量是不固定的，所以需要在常量池的入口放置一项u2类型的数据，代表着常量池容量计数值。这个容量计数是从1开始的而不是0。<blockquote><p>cafe babe 0000 0034 <font color="red"><strong>0013</strong></font> 0a00 0400 0f09<br><strong>0x0013转十进制为19，代表常量池中有18项常量，索引值范围为1~18。</strong></p></blockquote></li></ul><blockquote><p><strong>注</strong>：在Class文件格式规范制定的时候，设计者将第0项常量空出来是有特殊考虑的，这样做是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”，这种情况就可以把索引值设置为0来表示。</p></blockquote><p>常量池中主要存放两大类常量：</p><ul><li><p><strong>字面量</strong>（Literal）：字面量比较接近于Java语言层面的常量概念，如：</p><ul><li>文本字符串。</li><li>声明为final的常量值等。</li></ul></li><li><p><strong>符号引用</strong>（Symbolic Reference）：符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li><p>类和接口的全限定名（Fully Qualified Name）。</p><blockquote><p><strong>全限定名</strong>：以案例代码为例，“org/petsch/clazz/Test”就是这个类的全限定名，把类全名中的“.”替换成“/”。</p></blockquote></li><li><p>字段的名称和描述符（Descriptor）。</p></li><li><p>方法的名称和描述符。</p></li></ul></li></ul><p><strong>常量池中每一项常量都是一个表</strong>，在JDK 1.7共有14种结构各不相同的表结构数据。这14种表都有一个共同的特点，就是表开始的第一位是一个u1类型的标志位（tag），代表当前这个常量属于那种常量类型。</p><p><strong>常量池中的常量项结构</strong>：<img src="https://img-blog.csdnimg.cn/20210307013921444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="常量池"><br>接下来，我们拿第一项常量的标志位进行分析。</p><blockquote><p>cafe babe 0000 0034 0013 <font color="red"><strong>0a</strong></font>00 0400 0f09<br><strong>0x0000000a转十进制为10，表示标志位为10，这个常量属于CONSTANT_Methodref_info类型，此类型的常量代表指向声明方法描述符CONSTANT_Class_info的索引项</strong>。CONSTANT_Class_info该类型常量一共占用了5u，即<font color="red"><strong>0a 00 0400 0f</strong></font>，所以下一项的标志位为09，这次类推其余的常量可以通过类似的方式计算出来。</p></blockquote><p>接下来使用分析Class文件字节码的工具：javap，来验证下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">petsch</span>.<span class="title">clazz</span>.<span class="title">Test</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#15         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #3.#16         // org/petsch/clazz/Test.m:I</span><br><span class="line">   #3 = Class              #17            // org/petsch/clazz/Test</span><br><span class="line">   #4 = Class              #18            // java/lang/Object</span><br><span class="line">   #5 = Utf8               m</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               inc</span><br><span class="line">  #12 = Utf8               ()I</span><br><span class="line">  #13 = Utf8               SourceFile</span><br><span class="line">  #14 = Utf8               Test.java</span><br><span class="line">  #15 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">  #16 = NameAndType        #5:#6          // m:I</span><br><span class="line">  #17 = Utf8               org/petsch/clazz/Test</span><br><span class="line">  #18 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> org.petsch.clazz.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #2                  // Field m:I</span><br><span class="line">         <span class="number">4</span>: iconst_1</span><br><span class="line">         <span class="number">5</span>: iadd</span><br><span class="line">         <span class="number">6</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"Test.java"</span></span><br></pre></td></tr></table></figure><p>可以看出，上面的打印的常量池有18项，并且第一项和计算的结果一致。</p><h2 id="访问标志："><a href="#访问标志：" class="headerlink" title="访问标志："></a><strong>访问标志</strong>：</h2><p>常量池后面紧接着的两个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，如：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>是否为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>是否被声明为final，只有类可设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用invokespecial字节码指令的新语意</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标识这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标识这个类并非由用户代码产生的</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标识这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标识这是一个枚举</td></tr><tr><td>ACC_MODULE</td><td>0x4000</td><td>标识这是一个模块</td></tr></tbody></table><p>看看我们的案例代码，可以得出ACC_PUBLIC丶ACC_SUPER标志为真，其他的标志为假，既access_flags的值应该为：0x0001|0x0020 = 0x0021。（如果有多个，就使用按位或运算符 <strong>|</strong> ）</p><blockquote><p>….<br>6a65 6374 <font color="red"><strong>0021</strong></font> 0003 0004 0000 0001 0002<br>…</p></blockquote><h2 id="类索引丶父类索引与接口索引集合："><a href="#类索引丶父类索引与接口索引集合：" class="headerlink" title="类索引丶父类索引与接口索引集合："></a><strong>类索引丶父类索引与接口索引集合</strong>：</h2><p>访问标志之后，分别是类索引丶父类索引和接口索引集合，在Class文件中由这三项数据来确定这个类的继承关系。</p><ul><li><strong>类索引丶父类索引</strong>：类索引和父类索引用两个u2类型的索引值表示，类索引用于确定这个类的全限定名。父类索引用于确定这个类的父类的全限定名。它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过该常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</li></ul><blockquote><p><strong>类索引</strong><br>…6a65 6374 0021 <font color="red"><strong>0003</strong></font> 0004 0000 0001 0002<br>…<strong>0x0003转为十进制为3，即是指向的是常量池中的第3个常量。</strong><br>Constant pool:<br>   **#3 = Class              #17            // org/petsch/clazz/Test</p><p>  #17 = Utf8               org/petsch/clazz/Test**</p></blockquote><blockquote><p><strong>父类索引</strong><br>…6a65 6374 0021 0003 <font color="red"><strong>0004</strong></font> 0000 0001 0002<br>…<strong>0x0004转为十进制为4，即是指向的是常量池中的第4个常量。</strong><br>Constant pool:<br>   **#4 = Class              #18            // java/lang/Object</p><p>  #18 = Utf8               java/lang/Object**</p></blockquote><ul><li><strong>接口索引集合</strong>：是一组u2类型的数据集合，用于描述这个类实现了哪些接口<ul><li><strong>接口计数器</strong>（interfaces_count）：是接口索引集合入口的第一项，是u2类型的数据，表示索引表的容量。如果该类没有实现任何接口，则计数器值为0，后面接口的索引表不再占用任何字节。<blockquote><p>…6a65 6374 0021 0003 0004 <font color="red"><strong>0000</strong></font> 0001 0002<br>…<strong>十进制为0，代表我们的案例代码中的类没有实现任何接口。</strong></p></blockquote></li></ul></li></ul><h2 id="字段表集合："><a href="#字段表集合：" class="headerlink" title="字段表集合："></a>字段表集合：</h2><p>紧接着的是字段表，字段表（field_info）用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p><p><strong>字段表结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attributes_infdo</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><blockquote><p><strong>name_index</strong>和<strong>descriptor_index</strong>它们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符。<br><strong>简单名称</strong>：是指没有类型和参数修饰的方法或者字段名称。<br><strong>描述符</strong>：用来描述字段的数据类型丶方法的参数列表和返回值。</p></blockquote><p><strong>描述符标志字符含义</strong></p><table><thead><tr><th>标志字符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本类型byte</td></tr><tr><td>C</td><td>基本类型char</td></tr><tr><td>D</td><td>基本类型double</td></tr><tr><td>F</td><td>基本类型float</td></tr><tr><td>I</td><td>基本类型int</td></tr><tr><td>J</td><td>基本类型Long</td></tr><tr><td>S</td><td>基本类型short</td></tr><tr><td>Z</td><td>基本类型boolean</td></tr><tr><td>V</td><td>特殊类型void</td></tr><tr><td>L</td><td>对象类型，如Ljava/lang/Object</td></tr></tbody></table><blockquote><p>注：对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组，将被记录为“[[Ljava/lang/String;”。<br>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述。如方法void inc()的描述符为“()V”，int inc()的描述符为(I)I。</p></blockquote><p><strong>字段访问标志</strong></p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为enum</td></tr></tbody></table><blockquote><p>…6a65 6374 0021 0003 0004 0000 <font color="red"><strong>0001</strong></font> 0002<br>…<strong>首先是fields_count，类型是u2。即如上，十进制则是1，表示只有一个字段表数据。</strong></p></blockquote><blockquote><p>…6a65 6374 0021 0003 0004 0000 0001 <font color="red"><strong>0002</strong></font><br>…<strong>接下来紧接着的是acess_flags标志，值为0x0002，从上面的字段访问标志表可以得出是private修饰符。</strong></p></blockquote><blockquote><p>…<font color="red"><strong>0005</strong></font> 0006 0000 0002 0001 0007 0008 0001<br>…<strong>接下来是name_index，0x0005的十进制为5，表示常量池的第5项常量，其值为“m”</strong><br>Constant pool:<br>   <strong>#5 = Utf8               m</strong></p></blockquote><blockquote><p>…0005 <font color="red"><strong>0006</strong></font> 0000 0002 0001 0007 0008 0001<br>…<strong>接下来是descriptor_index，指向常量池的第六项常量，其值为“I”</strong><br>Constant pool:<br>   <strong>#6 = Utf8               I</strong></p></blockquote><p>从上面的推断，可以得出原代码的定义的字段为“private int m;”</p><blockquote><p>注：由于案例代码中的m字段，它的属性表计数器为0，也就是没有需要额外描述的信息，所以字段表的推断就结束了。下面介绍属性表的进一步推断。<br>别外，在Java语言中字段是无法重载的，两个字段的数据类型丶修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来说，如果两个字段的描述符不一致，那字段重名就是合法的。</p></blockquote><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>紧接后面的是方法表，方法表结构如同字段一样，依次包括了访问标志丶名称索引丶描述符索引丶属性表集合。</p><p><strong>方法表结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attributes_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><p><strong>方法访问标志</strong></p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>方法是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>方法是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>方法是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>方法是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>方法是否为final</td></tr><tr><td>ACC_SYNCHRONIZED</td><td>0x0020</td><td>方法是否为synchronized</td></tr><tr><td>ACC_BRIDGE</td><td>0x0040</td><td>方法是否由编译器生产的桥接方法</td></tr><tr><td>ACC_VARARGS</td><td>0x0080</td><td>方法是否接受不定参数</td></tr><tr><td>ACC_NATIVE</td><td>0x0100</td><td>方法是否为native</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>方法是否为abstract</td></tr><tr><td>ACC_STRICT</td><td>0x0800</td><td>方法是否为strictfp</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>方法是否由编译器自动生成</td></tr></tbody></table><blockquote><p>注：方法里面的代码，存放在方法属性表集会中一个名为“Code”的属性里面。具体请看下面的<strong>属性表</strong>。</p></blockquote><blockquote><p>…0005 0006 0000 <font color="red"><strong>0002</strong></font> 0001 0007 0008 0001<br>…<strong>值为0x0002，代表集会中有两个方法，一个是编译器添加的实例构造器&lt;init&gt;和源码中的inc()方法。</strong></p></blockquote><blockquote><p>…0005 0006 0000 0002 <font color="red"><strong>0001</strong></font> 0007 0008 0001<br>…<strong>第一个方法的访问标志为0x0001，也就是只有ACC_PUBLIC标志为真。</strong></p></blockquote><blockquote><p>…0005 0006 0000 0002 0001 <font color="red"><strong>0007</strong></font> 0008 0001<br>…<strong>名称索引值为0x0007，也就是指向常量池的第7项常量。方法名为“&lt;init&gt;”</strong><br>Constant pool:<br>   <strong>#7 = Utf8               &lt;init&gt;</strong></p></blockquote><blockquote><p>…0005 0006 0000 0002 0001 0007 <font color="red"><strong>0008</strong></font> 0001<br>…<strong>描述符索引值为0x0008，也就是指向常量池的第8项常量。对应的常量为“()V”</strong><br>Constant pool:<br>   <strong>#8 = Utf8               ()V</strong></p></blockquote><blockquote><p>…0005 0006 0000 0002 0001 0007 0008 <font color="red"><strong>0001</strong></font><br>…<strong>属性表计数器attributes_count的值为为0x0001，表示此方法的属性表集合有一项属性。</strong></p></blockquote><blockquote><p>…<font color="red"><strong>0009</strong></font> 0000 001d 0001 0001 0000 0005 2ab7<br>…<strong>属性名称索引为0x0009，对应常量是“Code”，说明此属性是方法的字节码描述。</strong><br>Constant pool:<br>   <strong>#9 = Utf8               Code</strong></p></blockquote><blockquote><p><strong>注</strong>：与字段表集合相对应的，如果父类方法在子类中灭有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，如类构造器“&lt;clinit&gt;”方法和实例构造器“&lt;init&gt;”方法。别外，在Class文件格式中，只要描述符不是完全一致的两个方法是可以共存的。</p></blockquote><h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>紧接后面的是属性表。在Class文件丶字段表和方法表都都有可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p><blockquote><p><strong>注</strong>：在Class文件中属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性名重复。虚拟机运行时会忽略掉不认识的属性。</p></blockquote><p><strong>虚拟机规范预定义的属性</strong><br><img src="https://img-blog.csdnimg.cn/20210311031143477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性来说明属性值所占用的位数即可。</p><p><strong>属性表结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u1</td><td>info</td><td>attribute_length</td></tr></tbody></table><h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a><strong>Code属性</strong></h3><p>Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性中。Code属性出现在方法表的属性集合中，但并未所有方法表都有这个属性，如接口或者抽象类中就不存在Code属性。</p><p><strong>Code属性表的结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>max_stack</td><td>1</td></tr><tr><td>u2</td><td>max_locals</td><td>1</td></tr><tr><td>u4</td><td>code_length</td><td>1</td></tr><tr><td>u1</td><td>code</td><td>code_length</td></tr><tr><td>u2</td><td>exception_table_length</td><td>1</td></tr><tr><td>exception_info</td><td>exception_table</td><td>exception_table_length</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attributes_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><ul><li><strong>attribute_name_index</strong>：是一项指向CONSTANT_Utf8_info类型常量的索引，常量值固定为“Code”，代表该属性的属性名称。</li><li><strong>attribute_length</strong>：代表了属性值的长度，由于属性名称索引类型是u2，属性长度类型是u4，总共占用了u6，所以属性值的长度固定为整个属性表长度减去6个字节。</li><li><strong>max_stack</strong>：代表了操作数栈（Operand Stacks）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。</li><li><strong>max_locals</strong>：代表了局部变量表所需的存储空间。单位是Slot，Slot是虚拟机为局部变量分配内存所使用的最小单位。对于byte丶char丶float丶int丶short丶boolean等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double丶long这种64位的数据类型则需要两个Slot。方法参数丶显式异常处理器的参数丶方法体中定义的局部变量都需要使用局部变量表来存放。另外，并不是把方法中所用的局部变量所占Slot之和作为max_locals的值，原因是局部变量表中的Slot是可以重用的，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用，Java编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小。</li><li><strong>code_length</strong>：代表字节码长度。另外，code_length是个u4类型的长度值，理论上最大值可以达到2^32-1，但是虚拟机规范中明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度，如果超过这个限制，Javac编译器会拒绝编译。</li><li><strong>code</strong>：是用于存储字节码指令的一系列字节流。每个字节码指令就是一个u1类型的单字码，当虚拟机读取到code中一个字节码时，就可以找出对应指令。u1类型的取值范围是0~255，也就是说一个可以表达256条指令。</li></ul><blockquote><p><strong>attribute_name_index前面已经分析过了，对应的是“Code”。接下来是attribute_length</strong><br>…<br>0009 <font color="red"><strong>0000 001d</strong></font> 0001 0001 0000 0005 2ab7<br>…<br><strong>十进制为29，即长度为29，往后的29个字节都是“Code”属性。</strong><br>…<br>0009 0000 001d <font color="red"><strong>0001 0001 0000 0005 2ab7<br>0001 b100 0000 0100 0a00 0000 0600 0100<br>0000 03</strong></font>00 0100 0b00 0c00 0100 0900 0000<br>…</p></blockquote><blockquote><p><strong>接下来是max_stack</strong><br>…<br>0009 0000 001d <font color="red"><strong>0001</strong></font> 0001 0000 0005 2ab7<br>…<br><strong>代表着操作数栈深度的最大值为0x0001。</strong></p></blockquote><blockquote><p><strong>max_locals</strong><br>…<br>0009 0000 001d <font color="red"><strong>0001</strong></font> 0001 0000 0005 2ab7<br>…<br><strong>局部变量表的容量为0x0001。</strong></p></blockquote><blockquote><p><strong>code_length</strong><br>…<br>0009 0000 001d 0001 <font color="red"><strong>0001</strong></font> 0000 0005 2ab7<br>…<br><strong>字节码长度为0x0005。</strong></p></blockquote><blockquote><p><strong>接下来到code了，上面分析到字节码的长度为5</strong><br>…<br>0009 0000 001d 0001 0001 0000 0005 <font color="red"><strong>2ab7<br>0001 b1</strong></font>00 0000 0100 0a00 0000 0600 0100<br>…<br>我们要根据字节码指令表翻译出“2ab7 0001 b1”。<br><strong>2A</strong>：查表的出0x2A对应的指令是aload_0，含义是将第0个Slot中为reference类型的本地变量推送到操作数栈顶。<br><strong>B7</strong>：0xB7对应的指令为invokespecial，作用是以栈顶的reference类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法丶private方法或者它的父类的方法。这个方法有一个u2类型的参数说明具体调用哪个方法，它指向常量池中的CONSTANT_Methodref_info类型常量，即此方法的方法符号引用。<br><strong>00 0A</strong>：这是invokespecial的参数，查常量池得0x000A对应的常量为实例构造器“&lt;init&gt;”方法的符号引用。<br><strong>B1</strong>：对应的指令为return，含义是返回此方法，并且返回值为void。</p></blockquote><p><strong>javap计算字节码指令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> org.petsch.clazz.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #2                  // Field m:I</span><br><span class="line">         <span class="number">4</span>: iconst_1</span><br><span class="line">         <span class="number">5</span>: iadd</span><br><span class="line">         <span class="number">6</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：使用javap中输出的“<strong>args_size</strong>”的值，为什么是1呢，&lt;init&gt;()和inc()方法很明显都是没有参数的。还有“<strong>locals</strong>”的值也是1呢？那是因为，在任何实例方法里面，都可以通过“<strong>this</strong>”关键字访问到此方法所属的对象。它的实现原理是，通过<strong>Javac编译器的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数</strong>而已。因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个Slot位来存放对象实例的引用，方法参数值从1开始计算。这个仅对实例方法有效，如果方法声明为static，那args_size的值就是0。</p></blockquote><p>字节码指令之后就是这个方法的显式异常处理表集合，异常表对于Code属性来说并不是必须存在的。</p><p><strong>异常表的结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>start_pc</td><td>1</td></tr><tr><td>u2</td><td>end_pc</td><td>1</td></tr><tr><td>u2</td><td>handler_pc</td><td>1</td></tr><tr><td>u2</td><td>catch_type</td><td>1</td></tr></tbody></table><blockquote><p>这些字段的含义为如果当字节码在第start_pc行到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info类型常量的索引），则转到handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转向到handler_pc处进行处理。</p></blockquote><p>案例代码2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            x = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            x = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 字节码以及异常表</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_1 <span class="comment">// try块中x=1入栈</span></span><br><span class="line">         <span class="number">1</span>: istore_1<span class="comment">// 将x=1存到本地变量表索引为1的位置</span></span><br><span class="line">         <span class="number">2</span>: iload_1<span class="comment">// 将存在本地变量表中索引为1的数值推至栈顶</span></span><br><span class="line">         <span class="number">3</span>: istore_2<span class="comment">// 将栈顶元素存到本地变量表索引为2的位置，即保存try中的返回值</span></span><br><span class="line">         <span class="number">4</span>: iconst_3<span class="comment">// final块中的x=3入栈</span></span><br><span class="line">         <span class="number">5</span>: istore_1<span class="comment">// 将x=3放入到本地变量表索引为1的位置</span></span><br><span class="line">         <span class="number">6</span>: iload_2<span class="comment">// 将存放在本地变量表中索引为2的数值推至栈顶</span></span><br><span class="line">         <span class="number">7</span>: ireturn<span class="comment">// 结束方法返回int，即返回x=1</span></span><br><span class="line">         <span class="number">8</span>: astore_2<span class="comment">// 将栈顶引用类型数值存到本地变量表索引为2的位置</span></span><br><span class="line">         <span class="number">9</span>: iconst_2<span class="comment">// catch中的x=2入栈</span></span><br><span class="line">        <span class="number">10</span>: istore_1<span class="comment">// 将x=2存到本地变量表索引为1的位置</span></span><br><span class="line">        <span class="number">11</span>: iload_1<span class="comment">// 将存在本地变量表中索引为1的数值推至栈顶</span></span><br><span class="line">        <span class="number">12</span>: istore_3<span class="comment">// 将栈顶元素存到本地变量表索引为3的位置，即保存catch中的返回值</span></span><br><span class="line">        <span class="number">13</span>: iconst_3<span class="comment">// final块中的x=3入栈</span></span><br><span class="line">        <span class="number">14</span>: istore_1<span class="comment">// 将x=3放入到本地变量表索引为1的位置</span></span><br><span class="line">        <span class="number">15</span>: iload_3<span class="comment">// 将存在本地变量表中索引为3的数值推到栈顶</span></span><br><span class="line">        <span class="number">16</span>: ireturn<span class="comment">// 当前方法返回int，即x=2</span></span><br><span class="line">        <span class="number">17</span>: astore        <span class="number">4</span>  <span class="comment">// 将栈顶引用类型数值存到本地变量表索引为4的位置</span></span><br><span class="line">        <span class="number">19</span>: iconst_3<span class="comment">// final块中的x=3入栈</span></span><br><span class="line">        <span class="number">20</span>: istore_1<span class="comment">// 将x=3放入到本地变量表索引为1的位置</span></span><br><span class="line">        <span class="number">21</span>: aload         <span class="number">4</span><span class="comment">// 将存在本地变量表中索引为4的数值推至栈顶</span></span><br><span class="line">        <span class="number">23</span>: athrow<span class="comment">// 将栈顶的数值作为异常或错误抛出</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">0</span>     <span class="number">4</span>     <span class="number">8</span>   Class java/lang/Exception</span><br><span class="line">             <span class="number">0</span>     <span class="number">4</span>    <span class="number">17</span>   any</span><br><span class="line">             <span class="number">8</span>    <span class="number">13</span>    <span class="number">17</span>   any</span><br><span class="line">            <span class="number">17</span>    <span class="number">19</span>    <span class="number">17</span>   any</span><br></pre></td></tr></table></figure><p>编译器为这段代码生成了4条异常表记录，对应4条可能出现的代码执行路径。（忽略第4条，这条奇怪的记录，为什么为产生有兴趣的人，可以去深究下）</p><ul><li>如果try语句块中出现属于Exception或者其子类的异常，则转到catch语句块处理。</li><li>如果try语句块中出现不属于Exception或者其子类的异常，则转到finally语句块处理。</li><li>如果catch语句块中出现任何异常，则转到finally语句块处理。</li></ul><p><strong>分析下字节码层面的执行过程</strong></p><blockquote><p>字节码中第0 ~ 3行所做的操作就是将整数1赋值给变量x，并且将此时x的值复制一份副本到本地变量表中，如果此时没有出现异常，则会继续执行到4 ~ 5行，将变量x赋值为3，然后将之前保存在本地变量表中的整数1读入到操作栈顶，最后ireturn指令会以int形式返回操作栈顶的数据，方法结束。如果出现了异常，PC寄存器指针将转到第8行，第8 ~ 16行所做的事情就是将2赋值给变量x，然后将变量x的值保存到本地变量表中，再将3赋值给变量x，最后将保存在本地变量表中的整数2读入到操作栈顶中。如果出现异常，且不属于Exception，则会转到第17行，执行下去，最后将栈顶的异常抛出，方法结束。</p></blockquote><h3 id="Exception属性"><a href="#Exception属性" class="headerlink" title="Exception属性"></a>Exception属性</h3><p>Exception属性是在方法表中与Code属性平级的一项属性，不要与前面的异常表混淆。其作用是列举出方法中可能抛出的受查异常（Checked Exception），也就是方法描述时在throws关键字后面列举的异常。</p><p><strong>Exception属性结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>number_of_exceptions</td><td>1</td></tr><tr><td>u2</td><td>exceptions_index_table</td><td>number_of_exceptions</td></tr></tbody></table><ul><li><strong>number_of_exceptions</strong>：表示方法可能抛出number_of_exceptions种受查异常，每一种受查异常使用一个exceptions_index_table项表示。</li><li><strong>exceptions_index_table</strong>：是一个指向常量池中CONSTANT_Class_info类型常量的索引，代表了该受查异常的类型。</li></ul><h3 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h3><p>LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，可以使用<font color="red">-g:none</font>或<font color="red">-g:lines</font>选项来取消生成这项信息。</p><blockquote><p>注：如果选择不生成LineNumberTable属性，对程序运行产生的最主要的影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，无法按照源码行来设置断点。</p></blockquote><p><strong>LineNumberTable属性结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>line_number_table_length</td><td>1</td></tr><tr><td>line_number_info</td><td>line_number_table</td><td>line_number_table_length</td></tr></tbody></table><ul><li><strong>line_number_table</strong>：是一个数量为line_number_table_length丶类型为line_number_info的集会，line_number_info表包括了start_pc和line_number两个u2类型的数据项，前者是字节码行号，后者是Java源码行号。</li></ul><h3 id="LocalVariableTable属性"><a href="#LocalVariableTable属性" class="headerlink" title="LocalVariableTable属性"></a>LocalVariableTable属性</h3><p>LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义之间的关系，它也不是运行时必需的属性，可以使用<font color="red">-g:none</font>或<font color="red">-g:vars</font>选项来取消生成这项信息。</p><blockquote><p>注：如果没有生成这项属性，最大的影响就是其他人引用这个方法时，所有的参数名称都将会丢失，IDE将会使用诸如arg0丶arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但会对代码编写带来不便，而且在调试期间无法根据参数名称从上下文中获取参数。</p></blockquote><p><strong>LocalVariableTable属性结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u4</td><td>local_variable_table_length</td><td>1</td></tr><tr><td>local_variable_info</td><td>local_variable_table</td><td>local_variable_table_length</td></tr></tbody></table><ul><li><strong>local_variable_info</strong>：代表一个栈帧与源码中的局部变量的关联、</li></ul><p><strong>local_variable_info项目结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>start_pc</td><td>1</td></tr><tr><td>u2</td><td>length</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>index</td><td>1</td></tr></tbody></table><ul><li><strong>start_pc丶length</strong>：分别代表了这个局部变量的生命周期开始的字节码偏移量以其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。</li><li><strong>name_index丶descriptor_index</strong>：都是指向常量池中CONSTANT_Utf8_info类型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。</li><li><strong>index</strong>：是这个局部变量在栈帧局部变量表中Slot的位置。</li></ul><blockquote><p>注：在JDK 1.5引入泛型之后，增加了一个属性：LocalVariableTypeTable，这个属性结构与LocalVariableTable非常相似，仅仅是把记录的字段描述符的descriptor_index替换成字段的特征签名（Signature）。</p></blockquote><h3 id="SourceFile属性"><a href="#SourceFile属性" class="headerlink" title="SourceFile属性"></a>SourceFile属性</h3><p>SourceFile属性用于记录生成这个Class文件的源码文件名称。这个属性也是可以选的，可以使用<font color="red">-g:none</font>或<font color="red">-g:source</font>选项来取消生成这项信息。对于大多数的类来说，类名和文件名是一致的，但是有些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。</p><p><strong>SourceFile属性结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>sourcefile_index</td><td>1</td></tr></tbody></table><ul><li><strong>sourcefile_index</strong>：是指向常量池中CONSTANT_Utf8_info类型常量的索引，常量值是源码文件的文件名。</li></ul><h3 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h3><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量才可以使用这项属性。</p><blockquote><p>注：虚拟机对于static类型的变量和非static类型变量的赋值方式是不同的。对于非static类型的变量的赋值是在实例构造器&lt;init&gt;方法中进行的，而对于类变量，则有两种方法可以选择：在类构造器&lt;clinit&gt;方法中或者使用ConstantValue属性。如果同时使用final和static来修饰一个变量，并且这个变量的数据类型是基于本类型或者java.lang.String的话，就生成ConstantValue属性来进行初始化，如果这个变量没被final修饰，或者并非基本类型及字符串，则将会选择在&lt;clinit&gt;方法中进行初始化。</p></blockquote><p><strong>ConstantValue属性结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>constantvalue_index</td><td>1</td></tr></tbody></table><ul><li><strong>constantvalue_index</strong>：代表了常量池中一个字面量常量的引用，根据字段类型的不同，字面量可以是CONSTANT_Long_info丶CONSTANT_Float_info丶CONSTANT_Double_info丶CONSTANT_Integer_info丶CONSTANT_String_info常量中的一种。</li></ul><h3 id="InnerClasses属性"><a href="#InnerClasses属性" class="headerlink" title="InnerClasses属性"></a>InnerClasses属性</h3><p>InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</p><p><strong>InnerClasses属性结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>number_of_classes</td><td>1</td></tr><tr><td>inner_classes_info</td><td>inner_classes</td><td>number_of_classes</td></tr></tbody></table><ul><li><strong>number_of_classes</strong>：代表需要记录多少个内部类信息，每一个内部类信息都由一个inner_classes_info表进行描述。</li></ul><p><strong>inner_classes_info表结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>inner_class_info_index</td><td>1</td></tr><tr><td>u2</td><td>outer_class_info_index</td><td>1</td></tr><tr><td>u2</td><td>inner_name_index</td><td>1</td></tr><tr><td>u2</td><td>inner_class_access_flags</td><td>1</td></tr></tbody></table><ul><li><strong>inner_class_info_index丶outer_class_info_index</strong>：都是指向常量池中CONSTANT_Class_info类型的索引，分别代表了内部类和宿主类的符号引用。</li><li><strong>inner_name_index</strong>：指向常量池中CONSTANT_Utf8_info类型常量的索引，代表这个内部类的名称，如果是匿名内部类，那么这项值为0.</li><li><strong>inner_class_access_flags</strong>：是内部类的访问标志。</li></ul><p><strong>inner_class_access_flags标志</strong></p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>内部类是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>内部类是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>内部类是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>内部类是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>内部类是否为final</td></tr><tr><td>ACC_INTERFACE</td><td>0x0020</td><td>内部类是否为接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>内部类是否为abstract</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>内部类是否为并非由用户代码产生的</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>内部类是否为注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>内部类是否为枚举</td></tr></tbody></table><h3 id="Deprecated及Synthetic属性"><a href="#Deprecated及Synthetic属性" class="headerlink" title="Deprecated及Synthetic属性"></a>Deprecated及Synthetic属性</h3><p>Deprecated及Synthetic两个属性都属于标志类型的布尔属性，Deprecated属性用于表示某个类丶字段或者方法，已经被定为不再推荐使用。Synthetic属性代表此字段或者方法并不是有Java源码直接产生的，而是由编译器自行添加的。</p><blockquote><p>注：在JDK 1.5之后，标识一个类丶字段或者方法是编译器自动产生的，也可以设置他们访问标志中的ACC_SYNTHETIC标志位，所有由非用户代码产生的类丶方法以字段都应当至少设置Synthetic属性和ACC_SYNTHETIC标志位中的一项，唯一的例外是实例构造器&lt;init&gt;方法和类构造器&lt;clinit&gt;方法。</p></blockquote><p><strong>Deprecated及Synthetic属性结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr></tbody></table><ul><li>attribute_length：这项的值必须为0x00000000，因为没有任何属性值需要设置。</li></ul><h3 id="StackMapTable属性"><a href="#StackMapTable属性" class="headerlink" title="StackMapTable属性"></a>StackMapTable属性</h3><p>StackMapTable是一个复杂的变长属性，位于Code属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，目的在与代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p><blockquote><p>注：StackMapTable属性中包含零至多个栈映射帧（Stack Map Frames），每个栈映射帧都显式或者隐式地代表了一个字节码偏移量，用于表示该执行到该字节码时局部变量表和操作数栈的验证类型。类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。</p></blockquote><p><strong>StackMapTable属性结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>number_of_entries</td><td>1</td></tr><tr><td>stack_map_frame</td><td>stack_map_frame_entries</td><td>number_of_entries</td></tr></tbody></table><blockquote><p>注：在虚拟机版本号大于或等于50.0的Class文件中，如果方法的Code属性中没有附带StackMapTable属性，那就意味着它带有一个隐式的StackMapTable属性。这个StackMapTable属性的作用等同于number_of_entries值为0的StackMapTable属性属性。一个方法的Code属性最多只能有一个StackMapTable属性，否则将抛出ClassFormatError异常。</p></blockquote><h3 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h3><p>StackMapTable属性是一个可选的定长属性，可以出现于类丶属性表和方法表结构的属性表中。任何类丶接口丶初始化方法或成员的泛型签名，如果包含了类型变量或者参数化类型，则Signature属性会为它记录泛型签名信息。之所以要专门使用一个属性去记录泛型类型，是因为Java语言的泛型采用的是擦除法实现的伪泛型。</p><blockquote><p>注：在字节码中，泛型信息编译之后都通通被擦除掉。使用擦除法的好处是实现简单丶非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。坏处是运行期无法像真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期反射时无法获取到泛型类型信息。Signature属性就是为了弥补这个缺陷而增设的，现在Java的反射API能够获取泛型类型，最终的数据来源也就是这个属性。</p></blockquote><p><strong>Signature属性结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>signature_index</td><td>1</td></tr></tbody></table><ul><li><strong>signature_index</strong>：值必须是一个对常量池的有效索引。常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示类签名丶方法类型签名或者字段类型签名。如果当前的Signature属性是类文件的属性，则这个结构表示类签名，如果是方法表的属性，则表示方法类型签名，如果是字段表的属性，则表示字段类型签名。</li></ul><h3 id="BootstrapMethods属性"><a href="#BootstrapMethods属性" class="headerlink" title="BootstrapMethods属性"></a>BootstrapMethods属性</h3><p>BootstrapMethods属性是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符。</p><blockquote><p>注：如果某个类文件结构的常量池中曾经出现过CONSTANT_InvokeDynamic_info类型的常量，那么这个类文件的属性表中必须存在一个明确的BootstrapMethods属性，类文件的属性表中最多只能有一个BootstrapMethods属性。</p></blockquote><p><strong>BootstrapMethods属性</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>num_bootstrap_methods</td><td>1</td></tr><tr><td>bootstrap_method</td><td>bootstrap_methods</td><td>num_bootstrap_methods</td></tr></tbody></table><ul><li><strong>num_bootstrap_methods</strong>：表示bootstrap_methods[]数组中的引导方法限定符的数量。</li><li><strong>bootstrap_methods[]</strong>：数组中每个成员包含了一个指向常量池CONSTANT_MethodHandle结构的索引值，代表了一个引导方法，还包含了这个引导方法静态参数的序列。</li></ul><p><strong>bootstrap_method属性结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>bootstrap_method_ref</td><td>1</td></tr><tr><td>u2</td><td>num_bootstrap_arguments</td><td>1</td></tr><tr><td>u2</td><td>bootstrap_arguments</td><td>num_bootstrap_arguments</td></tr></tbody></table><p>bootstrap_methodsp[]数组中的每个成员必须包含以下3项内容：</p><ul><li><strong>bootstrap_method_ref</strong>：值必须是一个对常量池的有效索引。常量池在该索引处的值必须是一个CONSTANT_MethodHandle_info结构。</li><li><strong>num_bootstrap_arguments</strong>：标识bootstrap_arguments[]数组成员数量。</li><li><strong>bootstrap_arguments[]</strong>：数组中每个成员必须是一个对常量池的有效索引。常量池在该索引处必须是下列结构之一：CONSTANT_String_info丶CONSTANT_String_info丶CONSTANT_Class_info丶CONSTANT_Integer_info丶CONSTANT_Long_info丶CONSTANT_Float_info丶CONSTANT_Double_info丶CONSTANT_MethodHandle_info丶CONSTANT_MethodType_info。</li></ul><p>参考文献：《Java虚拟机规范》丶《深入理解Java虚拟机》</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java Class文件详解&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存分配与回收策略</title>
    <link href="http://yoursite.com/2021/03/03/Java%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2021/03/03/Java 内存分配与回收策略/</id>
    <published>2021-03-03T15:36:30.000Z</published>
    <updated>2021-03-03T20:24:46.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 内存分配与回收策略</p><a id="more"></a><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代。</p><h3 id="1丶对象优先在Eden分配"><a href="#1丶对象优先在Eden分配" class="headerlink" title="1丶对象优先在Eden分配"></a>1丶对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><blockquote><p><strong>注</strong>：<strong>Minor GC</strong> 和 <strong>Full GC</strong>有什么不一样吗?</p><ul><li>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC 非常频繁，一般回收速度也比较快。</li><li>老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对，在Parallel Scavenger收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC 慢10倍以上。</li></ul></blockquote><p><strong>测试案例</strong></p><blockquote><p><strong>注</strong>：下面的代码在测试时使用Client模式虚拟机运行，验证的是在使用<strong>Serial / Serial Old收集器</strong>下的内存分配和回收的策略。</p></blockquote><p>在运行时通过<font color="red">-Xms20M -Xmx20M -Xmn10M</font>这3个参数限制了Java堆大小为20MB，其中新生代大小为10MB。新生代可用空间为9MB（9216KB）。</p><blockquote><p><strong>注</strong>：新生代总容量 = Eden区 + s0 + s1(两个Survivor区) 默认比例是8：1：1，每次只会用一个Survivor，两个交替使用。新生代可用空间为总空间容量的9/10。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * JVM参数 -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">       allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">       allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">       allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">       allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: <span class="number">8147</span>K-&gt;<span class="number">640</span>K(<span class="number">9216</span>K), <span class="number">0.0046079</span> secs] <span class="number">8147</span>K-&gt;<span class="number">6784</span>K(<span class="number">19456</span>K), <span class="number">0.0046526</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total <span class="number">9216</span>K, used <span class="number">4818</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space <span class="number">8192</span>K,  <span class="number">51</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff014930</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space <span class="number">1024</span>K,  <span class="number">62</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff5a0240</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  to   space <span class="number">1024</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line"> tenured generation   total <span class="number">10240</span>K, used <span class="number">6144</span>K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space <span class="number">10240</span>K,  <span class="number">60</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffc00030</span>, <span class="number">0x00000000ffc00200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3281</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 359<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><p>程序执行到allocation3后，已经创建了3个2MB大小的对象分配在Eden区，总大小为6MB，执行到allocation4时，剩余空间已不足以分配allocation4所需的4MB内存，因此触发Minor GC。在GC期间虚拟机发现已有的3个2MB大小的对象无法放入Survivor区，所以只好通过分配担保机制提前转移到老年代。<br>这次GC结束后，4MB的allocation4对象顺利分配到Eden区中，Eden区占用6M，Survivor空闲，老年代区被占用4M。</p><h3 id="2丶大对象直接进入老年代"><a href="#2丶大对象直接进入老年代" class="headerlink" title="2丶大对象直接进入老年代"></a>2丶大对象直接进入老年代</h3><p>所谓的大对象是指，需要大量连续内存空间的对象，比如很长的字符串以及数组。大对象堆虚拟机的内存分配来说就是个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p><blockquote><p><strong>注</strong>：虚拟机提供<font color="red">-XX:PretenureSizeThreshold</font>参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区以及Survivor区之前发生大量的内存复制。</p></blockquote><blockquote><p><strong>注</strong>：<font color="red">-XX:PretenureSizeThreshold</font>参数只对<strong>ParNew和Serial垃圾收集器</strong>有效，如果遇到必需使用该参数的话，可以考虑使用ParNew + CMS的组合。</p><p><strong>测试案例</strong></p></blockquote><p>通过设置<font color="red">-XX:PretenureSizeThreshold=3145728</font>，让大于3145728KB的对象直接进去老年代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * JVM参数 -Xms20M -Xmx20M -Xmn10M -XX:PretenureSizeThreshold=3145728 -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPretenureSizeThreshold</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">byte</span>[] allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total <span class="number">9216</span>K, used <span class="number">2167</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space <span class="number">8192</span>K,  <span class="number">26</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fee1dd98</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space <span class="number">1024</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line">  to   space <span class="number">1024</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line"> tenured generation   total <span class="number">10240</span>K, used <span class="number">4096</span>K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space <span class="number">10240</span>K,  <span class="number">40</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffa00010</span>, <span class="number">0x00000000ffa00200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3281</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 359<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><p>在执行代码后，我们看到Eden区空间几乎没有被使用，而老年代的10MB空间被使用了40%。也就是说4MB的allocation对象直接分配在老年代中。</p><h3 id="3丶长期存活的对象将进入老年代"><a href="#3丶长期存活的对象将进入老年代" class="headerlink" title="3丶长期存活的对象将进入老年代"></a>3丶长期存活的对象将进入老年代</h3><p>虚拟机采用了分代收集的思想来管理内存，那么哪些对象应放在新生代，哪些应放在老年代。为了做到这点，虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden区出生并经过第一次Minor GC后仍然存活，并且Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每经过一次Minor GC，年龄就增加1岁，当年龄增加到一定程度（默认15岁），将被晋升到老年代中。</p><blockquote><p><strong>注</strong>：虚拟机提供<font color="red">-XX:MaxTenuringThreshold</font>参数，用来设置对象晋升老年代的年龄阈值</p></blockquote><p><strong>测试案例</strong></p><p>通过设置<font color="red">-XX:MaxTenuringThreshold=1</font>，对象晋升到老年代区的年龄阈值为1，那么，当GC结束后，allocation1和allocation2均会进入老年代区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * JVM参数 -Xms20M -Xmx20M -Xmn10M -XX:MaxTenuringThreshold=1 -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">      allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">      allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">      allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">      allocation3 = <span class="keyword">null</span>;</span><br><span class="line">      allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: <span class="number">6355</span>K-&gt;<span class="number">870</span>K(<span class="number">9216</span>K), <span class="number">0.0033337</span> secs] <span class="number">6355</span>K-&gt;<span class="number">4966</span>K(<span class="number">19456</span>K), <span class="number">0.0033729</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: <span class="number">5050</span>K-&gt;<span class="number">1</span>K(<span class="number">9216</span>K), <span class="number">0.0012698</span> secs] <span class="number">9146</span>K-&gt;<span class="number">4964</span>K(<span class="number">19456</span>K), <span class="number">0.0012943</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total <span class="number">9216</span>K, used <span class="number">4235</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space <span class="number">8192</span>K,  <span class="number">51</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff022860</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space <span class="number">1024</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400758</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line">  to   space <span class="number">1024</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line"> tenured generation   total <span class="number">10240</span>K, used <span class="number">4962</span>K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space <span class="number">10240</span>K,  <span class="number">48</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffad8ae8</span>, <span class="number">0x00000000ffad8c00</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3277</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 359<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><p>通过GC日志发现，经过两次Minor GC，allocation1和allocation2均进入老年代区，allocation3在Eden区。</p><h3 id="4丶动态对象年龄判定"><a href="#4丶动态对象年龄判定" class="headerlink" title="4丶动态对象年龄判定"></a>4丶动态对象年龄判定</h3><p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了阈值才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代，无须等到阈值要求的年龄。</p><p><strong>测试案例</strong><br>通过设置<font color="red">-XX:MaxTenuringThreshold=15</font>，对象晋升到老年代区的年龄阈值为15，对象真的要等到15岁的临界年龄才能晋升到老年代吗?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM参数 -Xms20M -Xmx20M -Xmn10M -XX:MaxTenuringThreshold=15 -XX:+PrintGCDetails </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">null</span>;</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: <span class="number">6611</span>K-&gt;<span class="number">1023</span>K(<span class="number">9216</span>K), <span class="number">0.0046155</span> secs] <span class="number">6611</span>K-&gt;<span class="number">5224</span>K(<span class="number">19456</span>K), <span class="number">0.0046663</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: <span class="number">5203</span>K-&gt;<span class="number">0</span>K(<span class="number">9216</span>K), <span class="number">0.0017996</span> secs] <span class="number">9404</span>K-&gt;<span class="number">5224</span>K(<span class="number">19456</span>K), <span class="number">0.0018154</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total <span class="number">9216</span>K, used <span class="number">4234</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space <span class="number">8192</span>K,  <span class="number">51</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff022890</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space <span class="number">1024</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400208</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line">  to   space <span class="number">1024</span>K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line"> tenured generation   total <span class="number">10240</span>K, used <span class="number">5223</span>K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space <span class="number">10240</span>K,  <span class="number">51</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffb19ec8</span>, <span class="number">0x00000000ffb1a000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3281</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 359<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><p>通过GC日志发现，allocation1和allocation2对象都直接进入老年代，并没有等到15岁的临界年龄。因为这两个对象加起来已经到达了512KB，并且它们都是同年的，满足同年对象达到Survivor区空间的一半规则，所以它们进入老年代。</p><h3 id="5丶空间分配担保"><a href="#5丶空间分配担保" class="headerlink" title="5丶空间分配担保"></a>5丶空间分配担保</h3><p>在发生Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p><blockquote><p><strong>注</strong>：新生代使用复制算法，为了内存利用率，只使用其中一个Survivor区作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况，就需要老年代进行分配担保，把Survivor区无法容纳的对象直接进入老年代。进入老年代之前，虚拟机要确保老年代的空间是否能容纳这些对象。由于在垃圾回收之前是无法确定有多少对象存活下来。所以只好取之前每一次回收晋升到老年代对象的容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。取平均值毕竟是一种动态概率手段，如果某一次Minor GC后存活对象突增，远远高于平均值的话，依然会担保失败（Handle Promotion Failure）。如果出现担保失败，那只好发起一次Full GC。</p></blockquote><blockquote><p><strong>注</strong>：在JDK6 Update 24之前，虚拟机会读取<font color="red">-XX:-HandlePromotionFailure</font>参数的值判断是否允许担保失败。<br>在JDK6 Update 24之后，虽然源码中还定义了<font color="red">-XX:-HandlePromotionFailure</font>参数，但是不会再使用它，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</p></blockquote><p>HotSpot中空间分配检查的代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool TenuredGeneration::promotion_attempt_is_safe(size_t</span><br><span class="line">max_promotion_in_bytes) <span class="keyword">const</span> &#123;</span><br><span class="line">   <span class="comment">// 老年代最大可用的连续空间</span></span><br><span class="line">   size_t available = max_contiguous_available();  </span><br><span class="line">   <span class="comment">// 每次晋升到老年代的平均大小</span></span><br><span class="line">   size_t av_promo  = (size_t)gc_stats()-&gt;avg_promoted()-&gt;padded_average();</span><br><span class="line">   <span class="comment">// 老年代可用空间是否大于平均晋升大小，或者老年代可用空间是否大于当此GC时新生代所有对象容量</span></span><br><span class="line">   bool   res = (available &gt;= av_promo) || (available &gt;=</span><br><span class="line">max_promotion_in_bytes);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java 内存分配与回收策略&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 垃圾收集器</title>
    <link href="http://yoursite.com/2021/02/27/Java%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://yoursite.com/2021/02/27/Java 垃圾收集器/</id>
    <published>2021-02-27T15:59:36.000Z</published>
    <updated>2021-03-04T19:43:30.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java垃圾收集器</p><a id="more"></a><h1 id="新生代区垃圾收集器"><a href="#新生代区垃圾收集器" class="headerlink" title="新生代区垃圾收集器"></a>新生代区垃圾收集器</h1><h3 id="1丶Serial收集器"><a href="#1丶Serial收集器" class="headerlink" title="1丶Serial收集器"></a>1丶Serial收集器</h3><p>Serial收集器是最基础丶发展历史最悠久的收集器，在JDK 1.3之前是JVM 新生代区垃圾收集的唯一选择。Serial收集器是单线程的串行进行垃圾收集的收集器，而且，它在进行垃圾收集是必须要暂停所有的工作线程（<strong>Stop The World</strong> 简称STW），直到垃圾收集结束。<br><img src="https://img-blog.csdnimg.cn/20210228014838805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="Serial收集器"></p><blockquote><p><strong>注</strong>：看到这里，大家可能觉得Serial收集器是不是完全没用，但其实到现在，它依然是虚拟机运行在client模式下默认新生代区收集器。它也有优于其他收集器的地方，特别是单个CPU的环境来说，它有一个很明显的优点：简单而高效，Serial收集器由于没有线程交互的开销，专心做垃圾收集，自然可以获得最高的单线程收集效率。</p></blockquote><h3 id="2丶ParNew收集器"><a href="#2丶ParNew收集器" class="headerlink" title="2丶ParNew收集器"></a>2丶ParNew收集器</h3><p>ParNew收集器是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数丶收集算法丶Stop The World丶对象分配规则丶回收策略等都与Serial收集器完全一样。在hotspot的具体实现中，它们也共用了很多代码。<br><img src="https://img-blog.csdnimg.cn/20210228014859900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="ParNew收集器"></p><blockquote><p><strong>注</strong>：收集器在单CPU的环境下绝对不会有比Serial收集器更好的效果，是由于线程交互需要开销。当然，随着可用的CPU的数量增加，他对于GC时系统资源的有效利用还是很有好处的。</p></blockquote><h3 id="3丶Parallel-Scavenge收集器"><a href="#3丶Parallel-Scavenge收集器" class="headerlink" title="3丶Parallel Scavenge收集器"></a>3丶Parallel Scavenge收集器</h3><p>Parallel Scavenge是一款基于<strong>复制算法</strong>的新生代区垃圾收集器，它的垃圾收集也是并行的多线程收集器，它和ParNew收集器的区别，ParNew的相关优化的重点都是为了尽可能的缩短STW时间，但是Parallel Scavenge则是为了达到一个<strong>可控制</strong>的吞吐量，提高了吞吐量，也就可以更高效率的利用CPU。</p><blockquote><p><strong>注</strong>：<strong>吞吐量 = 运行时间 / (运行时间 + 垃圾收集时间)</strong></p></blockquote><blockquote><p>Paraller Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的<font color="red"><strong>-XX:MaxGCPauseMillis</strong></font>参数以及直接设置吞吐量大小的<font color="red"><strong>-XX:GCTimeRatio</strong></font>参数。大家不要认为把停顿时间设置小一点就能保证系统的垃圾收集变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：新生代调小了，小的空间当然会比大的空间收集快，当是同时也会导致垃圾收集发生的更频繁。</p></blockquote><blockquote><p>Paraller Scavenge收集器还有一个参数<font color="red"><strong>-XX:+UseAdaptiveSizePolicy</strong></font>这是个开关参数，当打开时，就不需要手动指定新生代的大小丶Eden与Survivor区的比例丶晋升老年代对象大小等，虚拟机会根据当前系统运行情况收集性能 监控信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量，这种调节方式称为<strong>GC自适应的调节策略</strong>。</p></blockquote><h1 id="老年代区垃圾收集器"><a href="#老年代区垃圾收集器" class="headerlink" title="老年代区垃圾收集器"></a>老年代区垃圾收集器</h1><h3 id="1丶Serial-Old收集器"><a href="#1丶Serial-Old收集器" class="headerlink" title="1丶Serial Old收集器"></a>1丶Serial Old收集器</h3><p>Serial Old是Serial收集器的老年代收集器版本，采用<strong>标记-整理算法</strong>，也是一个单线程的垃圾收集器。</p><blockquote><p><strong>注</strong>：在Server模式下，它主要还有两大用途：一种用途是在JDK1.5以及之前的版本中与Parallerl Scavvenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p></blockquote><h3 id="2丶Parallel-Old收集器"><a href="#2丶Parallel-Old收集器" class="headerlink" title="2丶Parallel Old收集器"></a>2丶Parallel Old收集器</h3><p>Parallel Old收集器是Parallel Scavenge的老年代收集器版本，同样采用<strong>标记-整理算法</strong>，和Serial Old相比，它是一个多线程的垃圾收集器。</p><blockquote><p><strong>注</strong>：该收集器是在JDK 1.6之后才提出的，在此之前，Parallel Scavenge只能与Serial Old搭配使用，由于Serial Old性能较低，所以就算使用Parallel Scavenge也并不能在整体上提升吞吐量。Parallel Old提出后该问题就迎刃而解了，在注重吞吐量的场合，可以考虑使用Parallel Scavenge + Parallel Old组合。</p></blockquote><h3 id="3丶CMS收集器"><a href="#3丶CMS收集器" class="headerlink" title="3丶CMS收集器"></a>3丶CMS收集器</h3><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。<br>从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于<strong>标记-清除</strong>算法实现的。<br><img src="https://img-blog.csdnimg.cn/20210302015603418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="CMS收集器"><br>运行过程主要分为以下四个部分：</p><table><thead><tr><th>过程</th><th align="center">内容</th></tr></thead><tbody><tr><td>初始标记（CMS initial mark）</td><td align="center">标记一下GC Roots能直接关联到的对象，速度很快。（需要STW）</td></tr><tr><td>并发标记（CMS concurrent mark）</td><td align="center">进行GC RootsTracing的过程。</td></tr><tr><td>重新标记（CMS remark）</td><td align="center">为了修正并发标记期间因用用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。（需要STW）</td></tr><tr><td>并发清除（CMS concurrent sweep）</td><td align="center">回收的可回收对象。</td></tr></tbody></table><p>由于整个过程中消耗最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p><strong>缺点</strong>：</p><ul><li><strong>CMS收集器对CPU资源非常敏感</strong>。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量降低。CMS默认启动的回收线程数是(CPU数量 + 3) / 4， 当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时，CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度降低。为了应付这种情况，虚拟机提供一种称为“增量式并发收集器”（Incremental Concurrent Mark Sweep/ i-CMS）的CMS收集器变种，所做的事情和单CPU操作系统使用抢占式来模拟多任务机制的思想一样，就是在并发标记丶清除的时候让GC线程丶用户线程交替运行，尽量减少GC线程的独占资源的时间，虽然会增加垃圾收集的时间，但是会减少用户程序的影响，程序执行速度下降就没那么明显。实践证明，i-CMS收集器效果很一般，不提倡用户使用。</li><li><strong>CMS收集器无法处理浮动垃圾</strong>（由于CMS并发清理阶段用户线程还在运行着，伴随程序运行生产新的垃圾，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留到下一次GC时再清理。这一部分垃圾就称为“浮动垃圾”），<strong>可能出现“Concurrent Mode Failure”失败而导致另外一次Full GC的产生</strong>。由于在垃圾收集阶段用户线程还需要运行，需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能等待老年代几乎填满再进行收集。在JDK 1.5中，CMS收集器当老年代使用了68%的空间就会被激活。在JDK1.6中，CMS收集的启动阈值提升到92%。（可使用<font color="red"><strong>-XX:CMSInitiatingOccupancyFraction</strong></font>参数设置触发的百分比，参数设置太高很容易导致大量“Concurrent Mode Failure”失败，性能反而降低。）要是CMS运行期间预留的内存无法满足程序需要就会出现一次“Concurrent Mode Failure”失败，这是虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li><li><strong>CMS是基于标记-清除算法的垃圾收集器，这就意味着收集结束时会产生大量空间碎片</strong>。空间碎片过多时，将会给大对象分配带来麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了<font color="red"><strong>-XX:+UseCMSCompactFullCollection</strong></font>参数（默认开启），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没了，但停顿时间变长了，虚拟机还提供了另一个参数<font color="red"><strong>-XX:+UseCMSFullGCsBeforeCompaction</strong></font>，用于设置执行多少次不压缩Full GC后，跟着来一次带压缩的（默认值为0.表示每次都进行压缩）</li></ul><h1 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h1><p>G1收集器是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是可以替换掉CMS收集器。<br><img src="https://img-blog.csdnimg.cn/20210305020121545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="G1收集器"></p><p>运行过程和<strong>CMS有很多相似</strong>，大致可分为以下四个部分：</p><table><thead><tr><th>过程</th><th align="center">内容</th></tr></thead><tbody><tr><td>初始标记（Initial Marking）</td><td align="center">标记一下GC Roots能直接关联到的对象，并且修改TAMS的值，速度很快。（需要STW）</td></tr><tr><td>并发标记（Concurrent Marking）</td><td align="center">进行GC RootsTracing的过程。</td></tr><tr><td>最终标记（Final Marking）</td><td align="center">为了修正在并发标记其他因用户程序运作而导致标记产生变动。虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set 中。（需要STW，但是可并行执行）</td></tr><tr><td>筛选回收（Live Date Counting and Evacuation）</td><td align="center">对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。（需要STW，但是可以与用户线程一起并发执行，停顿用户线程是为了大幅提高收集效率）</td></tr></tbody></table><p>与其他GC收集器相比，G1具备如下特点：</p><ul><li><strong>并行与并发</strong>：G1能充分利用多CPU丶多核环境下的硬件优势，使用多个CPU来缩短“Stop-The-World”停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li><li><strong>分代收集</strong>：与其他收集器一样，分代概念在G1依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间丶熬过多次GC的旧对象以获取更好的收集效果。</li><li><strong>空间整合</strong>：与CMS的“标记-清理”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li><li><strong>可预测的停顿</strong>：这是G1相对于CMS的别一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li></ul><p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。<strong>G1收集器，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的，它们都是一部分Region（不需要连续）的集合。</strong><br><img src="https://img-blog.csdnimg.cn/20210305020244820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="G1收集器构造"></p><p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的收集收集。G1跟踪各个Region里面的垃圾堆积大价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的由来）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p><blockquote><p>下面这部分内容，具体可以看下面补充的跨代引用</p></blockquote><p>在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用<strong>Remembered Set</strong>来避免全堆扫描的。G1中每个Region都有一个与之对应的<strong>Remembered Set</strong>，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个<strong>Write Barrier</strong>暂时中断写操作，检查Reference引用的对象是否处于不同的Region中（在分代的列子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，则通过<strong>Card Table</strong>把相关引用信息记录到被引用对象所属的Region的<strong>Remembered Set</strong>中。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h3 id="1丶CMS丶G1的并发标记"><a href="#1丶CMS丶G1的并发标记" class="headerlink" title="1丶CMS丶G1的并发标记"></a>1丶CMS丶G1的并发标记</h3><p>像Serial、Parallel之类的收集器，无论是单线程和多线程标记，本质采用的是暂停用户线程进行标记的算法，优点是实现简单，缺点就是标记时间长，导致STW的时间很长。而CMS和G1，采用的是并发标记，可以在不暂停用户线程的情况下对进行标记，实现这种并发标记的算法就是三色标记法。</p><h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a><strong>三色标记</strong></h4><ul><li><strong>白色</strong>：表示这个对象没有被垃圾收集器访问过。</li><li><strong>灰色</strong>：表示这个对象被垃圾收集器访问过，但是它存在一些引用还没被扫描过。</li><li><strong>黑色</strong>：表示这个对象被垃圾收集器访问过了，并且它的所有引用也都被扫描过，它绝对是存活的。<br><img src="https://img-blog.csdnimg.cn/20210305020955850.png#pic_center" alt="三色标记"></li></ul><p><strong>并发过程中产生的问题</strong><br><img src="https://img-blog.csdnimg.cn/20210305021307679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="三色标记问题"></p><blockquote><p>由于并发标记的过程中，用户线程并不会暂停，在标记的过程中，用户线程的操作可能会对某些对象的引用进行修改，如上图那样，白色对象明明是存活的，最终还是被回收了。</p></blockquote><p><strong>对象消失问题</strong>：扫描的过程中插入一条或者多条从黑色对象到白色对象的新引用，并且去掉了灰色对象到该白色对象的直接引用或者间接引用。</p><blockquote><p>解决方案：只需破坏这两个条件任意一个即可，CMS解决的方案是<strong>增量更新</strong>，G1解决的方案是<strong>原始快照</strong>。</p></blockquote><p><strong>增量更新</strong> （Incremental Update）（<strong>CMS处理的方案</strong>）当黑色对象新插入指向白色对象的新引用的时候，把这个新增引用关系记录下来，到了重新标记的阶段，再根据记录重新扫描一遍。</p><p><strong>原始快照</strong>（ Snapshot At The Begining : SATB）（<strong>G1处理的方案</strong>）当灰色对象删除掉到指向白色对象的引用的时候，把这个删除引用关系记录下来，到了最终标记的阶段，再根据记录重新扫描一遍。</p><h3 id="2丶跨代引用"><a href="#2丶跨代引用" class="headerlink" title="2丶跨代引用"></a>2丶<strong>跨代引用</strong></h3><p>跨代引用是指新生代中存在对老年代对象的引用，或者老年代中存在对新生代的引用。<br><img src="https://img-blog.csdnimg.cn/20210305023209997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="跨代引用"><br>如果新生代发生了垃圾回收的话，就不得不遍历整个老年代，但是这样做代价太多了，极大的浪费性能。那有什么解决方案呢？</p><p><strong>记忆集</strong>（<strong>Remembered Set</strong>）：一种数据结构，用于记录从非收集区域指向收集区域的指针集合。</p><blockquote><p>根据记录精度分三类：<br><strong>字长精度</strong>：记录精确到一个机器字长。<br><strong>对象精度</strong>：记录精确到一个对象。<br><strong>卡精度</strong>：每个记录精确到一块内存区域。</p></blockquote><p><strong>卡表</strong>（<strong>Card Table</strong>）：它是记忆集的一种实现。以第三种卡精度实现的记忆集，也是目前最常用的方式。记忆集是抽象的概念，而卡表就是记忆集的一种具体实现。</p><p><strong>卡表的实现</strong>：卡表是基于数组实现的：<strong>CARD_TABLE[this addredd &gt;&gt;9]=0</strong>，每个元素对应着非收集区域中的一块内存区域，称为“卡页”。HotSpot默认的卡页大小为2^9，即<strong>512字节</strong>，只要该内存区域发生跨代引用，对应的卡页的值就标为1，否则就标为0。<br><img src="https://img-blog.csdnimg.cn/20210305025828489.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="卡表"><br><strong>卡表的维护</strong>：简单来说，当老年代对象对新生代对象引用关系发生变化，卡表也要发生变化。那卡表的变化是通过什么来实现的呢？HotSpot通过写屏障技术来维护卡表状态。</p><p><strong>写屏障</strong>：写屏障可以看做在虚拟机层面对“引用类型字段赋值”动作的AOP切面，在赋值时会产生一个环形通知。赋值前称为“写前屏障”（Pre-Write Barrier），赋值后称为“写后屏障”（Post-Write Barrier）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java垃圾收集器&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java GC日志</title>
    <link href="http://yoursite.com/2021/02/20/Java%20GC%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2021/02/20/Java GC日志/</id>
    <published>2021-02-20T15:01:58.000Z</published>
    <updated>2021-02-20T20:04:29.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java GC 日志相关内容</p><a id="more"></a><h2 id="GC日志格式"><a href="#GC日志格式" class="headerlink" title="GC日志格式"></a>GC日志格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) --[PSYoungGen: 8192K-&gt;8192K(9216K)] 12288K-&gt;16392K(19456K), 0.0038111 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 8192K-&gt;2731K(9216K)] [ParOldGen: 8200K-&gt;8193K(10240K)] 16392K-&gt;10924K(19456K), [Metaspace: 3334K-&gt;3334K(1056768K)], 0.0056151 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure><p>GC日志开头的<code>[GC</code>和<code>[Full GC</code>代表这次垃圾收集的类型，</p><p><strong>注</strong>：</p><ul><li><p>这里并不是用来区分是新生代的GC还是老年代的GC。</p></li><li><p>如果是Full GC，只能说明这次GC是发生了STW（Stop-The-World）。</p></li></ul><p>接下来的是<code>[PSYoungGen</code>，<code>[ParOldGen</code>，<code>[Metaspace</code>表示GC发生的区域，这里的区域名与垃圾收集器是有相关的：</p><ul><li>如果是Serial收集器，那么新生代名称为<code>Default New Generation</code>，GC日志显示<code>[DefNew</code>；</li><li>如果是ParNew收集器，新生代的名称变成<code>Parallel New Gneration</code>，GC日志显示<code>[ParNew</code>；</li><li>如果是Parallel Scavenge收集器，gc日志则显示<code>[PSYoungGen</code></li></ul><p>区域名称后跟着的<code>8192K-&gt;8192K(9216K)</code>，它表示是在GC前该内存区域使用的量 -&gt; GC后该内存区域的使用量（该内存区域总容量）。在方括号后跟着的<code>12288K-&gt;16392K(19456K)</code>，它表示GC Heap已使用的量 -&gt; GC后Heap的使用量（Heap的总容量）。</p><p>在各个区域的GC相关内存变化之后，会给出该内存区域GC所用时间，有的收集器会给出具体的gc耗时时间数据，比如<code>[Times: user=0.02 sys=0.00, real=0.01 secs]</code>，可以看到，该时间数据包括3个时间：</p><ul><li><strong>user</strong>：用户态消耗的cpu时间；</li><li><strong>sys</strong>：内核态消耗的cpu时间；</li><li><strong>real</strong>：操作从开始到结束所经过的实际时间</li></ul><p><strong>注</strong>：real时间包括各种非运算的等待耗时，比如等待磁盘I/O，但是cpu时间是不包括这些耗时的。</p><p>既然real的时间包括等待时间，而user和sys不包括等待时间，为什么好多时候user或者sys的时间会超过real？</p><p>那是因为现在绝大多数服务器都是多cpu丶多核的，当多个线程操作时，user和sys会叠加这些cpu时间，所以出现这种现象是很正常的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java GC 日志相关内容&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>TCP 三次握手 四次挥手</title>
    <link href="http://yoursite.com/2021/02/17/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%20%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://yoursite.com/2021/02/17/TCP 三次握手 四次挥手/</id>
    <published>2021-02-17T15:59:36.000Z</published>
    <updated>2021-02-16T19:10:31.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TCP 三次握手 四次挥手</p><a id="more"></a><h2 id="TCP的连接和建立"><a href="#TCP的连接和建立" class="headerlink" title="TCP的连接和建立"></a>TCP的连接和建立</h2><p>TCP的连接和建立主要关注报文中的几个字段</p><table><thead><tr><th>字段</th><th>长度(bit)</th><th>含义</th></tr></thead><tbody><tr><td>序号</td><td>32</td><td>TCP链接中传输的数据流中每个字节都编上一个序号。序号字段的值指的是本报文段所发送的数据的第一个字节的序号。</td></tr><tr><td>确认号</td><td>32</td><td>是期望收到对方的下一个报文段的数据的第1个字节的序号，即上次已成功接收到的数据字节序号加1。只有ACK标识为1，此字段有效。</td></tr><tr><td>ACK</td><td>1</td><td>确认号有效标识。只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。</td></tr><tr><td>SYN</td><td>1</td><td>同步序号标识，用来发起一个连接。SYN=1表示这是一个连接请求或连接接受请求。</td></tr><tr><td>FIN</td><td>1</td><td>发端完成发送任务标识。用来释放一个连接。FIN=1表明此报文段的发送端的数据已经发送完毕，并要求释放连接。</td></tr></tbody></table><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP/IP采用三次握手来建立连接<br><img src="https://img-blog.csdnimg.cn/20210216164515717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="三次握手"></p><table><thead><tr><th>过程</th><th>报文</th><th>含义</th></tr></thead><tbody><tr><td>第一次握手</td><td>SYN = 1, seq = x</td><td>Client向Server发送一个连接请求 SYN = 1(表示这个报文是一个连接请求)，同时发送自己的序号seq = x</td></tr><tr><td>第二次握手</td><td>SYN = 1, ACK = 1, ack = x + 1, seq = y</td><td>收到Client发来的报文，回复Client一个确认报文作为应答 ACK = 1(确认报文)，接着发送一个确认号ack = x + 1(+1是代表它收到了SYN标识)，SYN = 1（代表连接接受请求），同时发送自己的序号seq = y</td></tr><tr><td>第三次握手</td><td>ACK = 1, ack = y + 1</td><td>Client收到Server的响应报文，它也要回复确认报文 ACK = 1(代表确认报文)，ack = Y + 1(对方的序号+1，表示收到对方的SYN标识)</td></tr></tbody></table><p><strong>注</strong>：为啥要3次握手<br>前两次握手 客户端可以知道服务器可以收到报文，也可以发送给我，但是服务器并不知道客户端能否收到，所有需要三次握手，即客户端再发送一个确认报文</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>TCP/IP采用四次挥手来关闭连接<br><img src="https://img-blog.csdnimg.cn/20210216170017448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="四次挥手"></p><table><thead><tr><th>过程</th><th>报文</th><th>含义</th></tr></thead><tbody><tr><td>第一次挥手</td><td>FIN = 1, seq = x</td><td>Client发送一个FIN = 1的包(代表要释放连接)，同时发送自己的序号 seq = x</td></tr><tr><td>第二次挥手</td><td>ACK = 1, ack = x + 1</td><td>Server收到Client的FIN包，则发送一个确认包，表示自己接受到Client的关闭连接请求（还没准备好关闭连接）</td></tr><tr><td>第三次挥手</td><td>FIN = 1, seq = y</td><td>当Server准备好关闭连接时，向Client发送结束连接请求，FIN置为1，同时发送自己的序号seq = y</td></tr><tr><td>第四次挥手</td><td>ACK = 1, ack = y + 1</td><td>Client接收到Server的关闭请求，发送一个确认包，Server收到确认包，就会关闭连接，进入CLOSED状态，Server关闭后，将不再回应Client，Client等待某个时间后，将会自行关闭，进入CLOSED状态，这时完成TCP连接释放</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;TCP 三次握手 四次挥手&lt;/p&gt;
    
    </summary>
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>TCP报文格式</title>
    <link href="http://yoursite.com/2021/02/17/TCP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/"/>
    <id>http://yoursite.com/2021/02/17/TCP报文格式/</id>
    <published>2021-02-17T15:59:36.000Z</published>
    <updated>2021-02-16T19:04:49.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TCP报文格式</p><a id="more"></a><h2 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h2><p>TCP/IP协议定义了一个在因特网上传输的包，称为IP数据报，由首部和数据两部分组成。IP报头中包含大量的信息，如源IP地址丶目的IP地址丶IP版本号丶数据报长度等。数据部分保存着传输层的数据丶如TCP丶UDP丶ICMP等数据</p><p>组成如下：<br><img src="https://img-blog.csdnimg.cn/20210216002105666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="IP数据报"></p><h2 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h2><p>其依然由首部和数据部分组成<br><img src="https://img-blog.csdnimg.cn/20210216002432349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="TCP报文"></p><table><thead><tr><th>字段</th><th>长度(bit)</th><th>含义</th></tr></thead><tbody><tr><td>源端口</td><td>16</td><td>标识哪个应用程序发送。</td></tr><tr><td>目的端口</td><td>16</td><td>标识哪个应用程序接收。</td></tr><tr><td>序号</td><td>32</td><td>TCP链接中传输的数据流中每个字节都编上一个序号。序号字段的值指的是本报文段所发送的数据的第一个字节的序号。</td></tr><tr><td>确认号</td><td>32</td><td>是期望收到对方的下一个报文段的数据的第1个字节的序号，即上次已成功接收到的数据字节序号加1。只有ACK标识为1，此字段有效。</td></tr><tr><td>数据偏移</td><td>4</td><td>即首部长度，指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，以32比特（4字节）为计算单位。最多有60字节的首部，若无选项字段，正常为20字节。</td></tr><tr><td>保留</td><td>6</td><td>暂时可忽略，值必须填0。</td></tr><tr><td>URG</td><td>1</td><td>紧急指针有效标识。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）。</td></tr><tr><td>ACK</td><td>1</td><td>确认号有效标识。只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。</td></tr><tr><td>PSH</td><td>1</td><td>标识接收方应该尽快将这个报文段交给应用层。接收到PSH = 1的TCP报文段，应尽快的交付接收应用进程，而不再等待整个缓存都填满了后再向上交付。</td></tr><tr><td>PST</td><td>1</td><td>重建连接标识。当RST=1时，表明TCP连接中出现严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立连接。</td></tr><tr><td>SYN</td><td>1</td><td>同步序号标识，用来发起一个连接。SYN=1表示这是一个连接请求或连接接受请求。</td></tr><tr><td>FIN</td><td>1</td><td>发端完成发送任务标识。用来释放一个连接。FIN=1表明此报文段的发送端的数据已经发送完毕，并要求释放连接。</td></tr><tr><td>窗口</td><td>16</td><td>TCP的流量控制，窗口起始于确认序号字段指明的值，这个值是接收端正期望接收的字节数。窗口最大为65535字节。</td></tr><tr><td>校验和</td><td>16</td><td>包括TCP首部和TCP数据，是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。</td></tr><tr><td>紧急指针</td><td>16</td><td>只有当URG标志置1时紧急指针才有效。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。紧急指针指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。</td></tr><tr><td>选项</td><td>可变</td><td>又称为MSS。每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。</td></tr><tr><td>填充</td><td>可变</td><td>选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。</td></tr><tr><td>数据部分</td><td>可变</td><td>该TCP协议包负载的数据</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;TCP报文格式&lt;/p&gt;
    
    </summary>
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 对象</title>
    <link href="http://yoursite.com/2020/01/13/Java%20%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2020/01/13/Java 对象/</id>
    <published>2020-01-13T15:36:30.000Z</published>
    <updated>2021-02-19T14:37:59.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java对象的探秘</p><a id="more"></a><h2 id="1丶对象的创建"><a href="#1丶对象的创建" class="headerlink" title="1丶对象的创建"></a>1丶对象的创建</h2><p><img src="https://img-blog.csdnimg.cn/20210219111702420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="对象的创建过程"></p><h3 id="new指令和类加载检查"><a href="#new指令和类加载检查" class="headerlink" title="new指令和类加载检查"></a>new指令和类加载检查</h3><p>当虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载丶解析和初始化过。如果没有，那么必须先执行相应的类加载过程。</p><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p><h4 id="1丶分配方式："><a href="#1丶分配方式：" class="headerlink" title="1丶分配方式："></a>1丶分配方式：</h4><ul><li><strong>指针碰撞</strong>：假设Java堆中内存是绝对规整的，所有用过的内存都放一边，空闲的内存放别外一边，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅是把指针向空闲空间那边挪动一段对对象大小相等的距离，这个分配方式称为“指针碰撞”。</li><li><strong>空闲列表</strong>：如果Java堆中的内存不是规整的，已使用内存与空闲内存相互交错，那就没办法进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。</li></ul><p>选择哪种分配方式是由Java堆是否规整决定的，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定的。</p><h4 id="2丶并发问题："><a href="#2丶并发问题：" class="headerlink" title="2丶并发问题："></a>2丶并发问题：</h4><p>在并发情况且不是线程安全的的情况下，可能出现出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用原来的指针来分配内存。解决这个问题有两种方案，</p><p><strong>解决方案</strong>：</p><ul><li><strong>CAS配上失败重试的方法</strong>：一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。<ul><li><strong>TLAB</strong>：一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。</li></ul></li></ul><h3 id="内存空间初始化"><a href="#内存空间初始化" class="headerlink" title="内存空间初始化"></a>内存空间初始化</h3><p>分配内存完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h3 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h3><p>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例丶如何才能找到类的元数据信息丶对象的哈希码丶对象的GC分代年龄等信息。这些信息存在对象的对象头之中。</p><h3 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行<init>方法</init></h3><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始——<init>方法还没执行，所有的字段都还为零。所以一般来说执行new指令之后会接着执行<init>方法，这样一个真正可用的对象才算完成产生出来。</init></init></p><h2 id="2丶对象的内存布局"><a href="#2丶对象的内存布局" class="headerlink" title="2丶对象的内存布局"></a>2丶对象的内存布局</h2><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头丶实例数据丶对齐填充。</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>非数组对象的对象头包括两部分信息：Mark Word，类型指针。数组对象的对象头还必须要有一块用于记录数组长度的数据。</p><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32bit/64bit</td><td>Mark Word</td><td>哈希码丶GC分代年龄丶锁状态标志等</td></tr><tr><td>32bit/64bit</td><td>类型指针</td><td>即对象指向它的类元数据的指针</td></tr><tr><td>32bit/32bit</td><td>数组长度</td><td>记录数组的长度</td></tr></tbody></table><h4 id="1丶Mark-Word"><a href="#1丶Mark-Word" class="headerlink" title="1丶Mark Word"></a>1丶Mark Word</h4><p>对象头包括两部分信息，第一部分用于存储对象自身的运行是数据，如哈希码丶GC分代年龄丶锁状态标志丶线程持有的锁丶偏向线程ID丶偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32位丶64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p><p><strong>32位虚拟机</strong><br>markOop.hpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//  32 bits:</span><br><span class="line">//  --------</span><br><span class="line">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span><br><span class="line">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span><br><span class="line">//             size:32 ------------------------------------------&gt;| (CMS free block)</span><br><span class="line">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span><br></pre></td></tr></table></figure><p>在运行期间，随着锁标志位的变化，Mark Word可以变化成以下几种类型的数据：<br><img src="https://img-blog.csdnimg.cn/20210218005123591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="32位虚拟机"><br><strong>64位虚拟机</strong><br>markOop.hpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//  64 bits:</span><br><span class="line">//  --------</span><br><span class="line">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span><br><span class="line">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span><br><span class="line">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span><br><span class="line">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span><br></pre></td></tr></table></figure><p>在运行期间，随着锁标志位的变化，Mark Word可以变化成以下几种类型的数据：<br><img src="https://img-blog.csdnimg.cn/2021021800514977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="64位虚拟机"></p><h4 id="2丶类型指针"><a href="#2丶类型指针" class="headerlink" title="2丶类型指针"></a>2丶类型指针</h4><p>对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h4 id="3丶数组长度"><a href="#3丶数组长度" class="headerlink" title="3丶数组长度"></a>3丶数组长度</h4><p>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。</p><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>接下来的实例数据部分是对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是子类中定义的，都需要记录到实例数据中。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>第三部分对齐填充并不是必然存在的，它仅仅起着占位符的作用，由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h2 id="3丶对象的访问定位"><a href="#3丶对象的访问定位" class="headerlink" title="3丶对象的访问定位"></a>3丶对象的访问定位</h2><p>建立对象是为了使用对象，Java程序需要通过栈上的reference数据来操作堆上的具体对象。</p><p>由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位丶访问堆中的对象的具体位置，所以对象访问方式取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。</p><h3 id="句柄方式："><a href="#句柄方式：" class="headerlink" title="句柄方式："></a>句柄方式：</h3><p>Java堆中将会划分出一块来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据各自的具体地址。</p><p><strong>通过句柄访问对象</strong><br><img src="https://img-blog.csdnimg.cn/20210217021406842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="通过句柄访问对象"></p><h3 id="直接指针方式："><a href="#直接指针方式：" class="headerlink" title="直接指针方式："></a>直接指针方式：</h3><p>Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。</p><p><strong>通过直接指针访问对象</strong><br><img src="https://img-blog.csdnimg.cn/20210217021521209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="通过直接指针访问对象"></p><h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><p>使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据的指针，而reference本身不需要修改。</p><p>使用直接指针访问方式最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。Sun HotSpot使用第二种方式进行对象访问，但是从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p><p>参考文献：《Java虚拟机规范》丶《深入理解Java虚拟机》</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java对象的探秘&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存模型与线程</title>
    <link href="http://yoursite.com/2020/01/12/Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/01/12/Java 内存模型与线程/</id>
    <published>2020-01-12T15:59:36.000Z</published>
    <updated>2021-02-16T17:36:30.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java内存模型与线程</p><a id="more"></a><h1 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h1><h2 id="1丶硬件的效率与一致性"><a href="#1丶硬件的效率与一致性" class="headerlink" title="1丶硬件的效率与一致性"></a>1丶硬件的效率与一致性</h2><p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器的运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复杂到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p><p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性。在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主内存，当多个处理器的运算任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致。为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI丶MESI丶MOSI丶Synapse丶Firefly等。</p><p><strong>处理器丶高速缓存丶主内存间的交互关系</strong><br><img src="https://img-blog.csdnimg.cn/20210217010309611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="处理器丶高速缓存丶主内存间的交互关系"></p><p>除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖别外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instrucion Reorder）优化。</p><h2 id="2丶Java的内存模型"><a href="#2丶Java的内存模型" class="headerlink" title="2丶Java的内存模型"></a>2丶Java的内存模型</h2><p>Java虚拟机规范中试图定义一种Java内存模型（JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p><h3 id="2-1丶主内存与工作内存"><a href="#2-1丶主内存与工作内存" class="headerlink" title="2.1丶主内存与工作内存"></a>2.1丶主内存与工作内存</h3><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程中所说的变量有所区别，它包括实例字段丶静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。</p><p>Java内存模型规定了所有的变量都存储在主内存中（此处的主内存与物理硬件时的主内存名字一样，两者也可以互相类比，但此处近视虚拟机内存的一部分）。每条线程还有自己的工作内存（可与前面说的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取丶赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方的工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><p>这里所说的主内存丶工作内存与Java内存区域中的Java堆丶栈丶方法去等并不是统一层次的内存划分，两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量丶主内存丶工作内存的定义来看，主内存主要对应与Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行是主要访问读写的是工作内存。</p><p><strong>Java线程丶工作内存丶主内存间的交互关系</strong><br><img src="https://img-blog.csdnimg.cn/2021021701035735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="Java线程丶工作内存丶主内存间的交互关系"></p><h3 id="2-2丶内存间交互操作"><a href="#2-2丶内存间交互操作" class="headerlink" title="2.2丶内存间交互操作"></a>2.2丶内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存丶如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的丶不可再分的。</p><ul><li><strong>lock</strong>(锁定)：作用于主内存的变量，它把一个变量标记为一条线程独占的状态。</li><li><strong>unlock</strong>(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li><strong>read</strong>(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li><strong>load</strong>(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><strong>use</strong>(使用)：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时执行这个操作。</li><li><strong>assign</strong>(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><strong>store</strong>(存储)：作用于工作内存的变量，它把工作内存中一个变量的值传递到主内存中，以便随后的write操作使用。</li><li><strong>write</strong>(写入)：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放到主内存的变量中。</li></ul><p> <strong>注</strong>：Java内存模型还规定了在执行这8种基本操作时要满足某些规则，后续再提</p><p>参考文献：《Java虚拟机规范》丶《深入理解Java虚拟机》</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java内存模型与线程&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 垃圾收集算法</title>
    <link href="http://yoursite.com/2020/01/08/Java%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/01/08/Java 垃圾收集算法/</id>
    <published>2020-01-08T15:01:58.000Z</published>
    <updated>2021-03-02T17:33:25.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java GC 垃圾收集算法 </p><a id="more"></a><h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h2><h3 id="1丶引用计数算法"><a href="#1丶引用计数算法" class="headerlink" title="1丶引用计数算法"></a>1丶引用计数算法</h3><p><img src="https://img-blog.csdnimg.cn/20210220154758926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="引用计数算法"></p><p>引用计数算法的基本思路是就是给对象添加一个引用计数器，每当一个地方引用它时，计数器的值就加1；但引用失效时，计数器的值就减一；任何时刻计数器为0的对象就是不可能再被使用的。<br><img src="https://img-blog.csdnimg.cn/2021022015065765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="引用计数算法"><br><strong>缺点</strong>：引用计数算法它很难解决对象之间互相循环引用的问题。</p><h3 id="2丶可达性分析算法"><a href="#2丶可达性分析算法" class="headerlink" title="2丶可达性分析算法"></a>2丶可达性分析算法</h3><p><img src="https://img-blog.csdnimg.cn/20210220150816422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="可达性分析算法"><br>可达性分析算法的基本思路就是通过一系列的称为“<strong>GC Roots</strong>”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p><p>可作为<strong>GC Roots</strong>的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常亮引用的对象。</li><li>本地方法栈中JNI（一般说的Native方法）引用的对象。</li></ul><blockquote><p><strong>注</strong>：即使是不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象的死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过了，虚拟机将这两种情况都视为“没有必要执行”。<br>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置到一个叫做F-Queue的队列中，并稍后由虚拟机自动建立的丶低优先级的Finalizer线程去执行它。这里的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，将可能会导致F-Queue队列中其他对象永久对于等待，甚至导致整个内存回收系统奔溃。finalize()方法是对象逃脱死亡的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果这时对象和引用链上的任何对象建立关联，那么它将会被移除出“即将回收”的集合；如果这时对象没有和引用链相连的话，那么它就真的被回收了。</p></blockquote><blockquote><p><strong>谈下引用</strong><br>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2之前，Java中的引用得到定义很传统：如果reference类型的数据中存储数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为<strong>强引用丶软引用丶弱引用丶虚引用</strong>，这4钟引用强度依次逐渐减弱。</p><ul><li><strong>强引用</strong>指在程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li><li><strong>软引用</strong>是用来描述一些还有用但是并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。</li><li><strong>弱引用</strong>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下次垃圾收集发生之前。当垃圾收集工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</li><li><strong>虚引用</strong>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</li></ul></blockquote><h2 id="垃圾清除算法"><a href="#垃圾清除算法" class="headerlink" title="垃圾清除算法"></a>垃圾清除算法</h2><h3 id="1丶标记-清除算法"><a href="#1丶标记-清除算法" class="headerlink" title="1丶标记-清除算法"></a>1丶标记-清除算法</h3><p><img src="https://img-blog.csdnimg.cn/20210220150953198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="标记-清除算法"><br>标记-清除算法是收集算法中最基础的算法，算法分为“标记”和“清除”两个阶段：首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象，之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这个思路进行改进的。</p><p><strong>缺点</strong>：一个是效率问题，标记和清除两个过程的效率都不高；别一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发别一次的垃圾收集动作。</p><h3 id="2丶复制算法"><a href="#2丶复制算法" class="headerlink" title="2丶复制算法"></a>2丶复制算法</h3><p><img src="https://img-blog.csdnimg.cn/20210220151201621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="复制收集算法"><br>复制收集算法是为了解决效率问题，所产生的，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块内存用完了，就将还存活着的对象复制到别外一块上面，然后在把已使用过的内存空间一次清理掉。这样使得每次都是对着整个半区进行内存回收，内存分配是也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p><p><strong>缺点</strong>：将内存缩小为了原来的一半，代价未免太高了。</p><h3 id="3丶标记-整理算法"><a href="#3丶标记-整理算法" class="headerlink" title="3丶标记-整理算法"></a>3丶标记-整理算法</h3><p><img src="https://img-blog.csdnimg.cn/20210220151400420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="标记-整理"><br>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都是100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据老年代的特点，有人提出了别外一种“标记-整理”算法，标记的过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h3 id="4丶分代收集算法"><a href="#4丶分代收集算法" class="headerlink" title="4丶分代收集算法"></a>4丶分代收集算法</h3><p><img src="https://img-blog.csdnimg.cn/20210220151521259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="分代收集算法"><br>分代收集算法，根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外空间怼它进行分配担保，就必须使用“标记-清除”或者“<strong>标记-整理</strong>”算法来进行回收。</p><h2 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h2><p>待续</p><p>参考文献：《Java虚拟机规范》丶《深入理解Java虚拟机》</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java GC 垃圾收集算法 &lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存区域</title>
    <link href="http://yoursite.com/2020/01/07/Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2020/01/07/Java 内存区域/</id>
    <published>2020-01-07T15:01:58.000Z</published>
    <updated>2021-02-27T18:02:36.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 内存区域 </p><a id="more"></a><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将包括以下几个运行时数据区域。</p><p><strong>Java虚拟机运行时数据区</strong><br><img src="https://img-blog.csdnimg.cn/20210217015038278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FteWFja2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="1丶程序计数器"><a href="#1丶程序计数器" class="headerlink" title="1丶程序计数器"></a>1丶程序计数器</h2><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支丶循环丶跳转丶异常处理丶线程恢复等基础功能都需要依赖计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立地程序计数器，各条线程之间计数器互不影响，独立储存，所以这块内存区域是线程私有的。</p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器的值则为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h2 id="2丶Java虚拟机栈"><a href="#2丶Java虚拟机栈" class="headerlink" title="2丶Java虚拟机栈"></a>2丶Java虚拟机栈</h2><p>和程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。它描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表丶操作数栈丶动态链接丶方法出口等信息。每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>局部变量表存放了编译器可知的各种基本数据类型丶对象引用（reference类型）和returnAddress类型</p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>该区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p><h2 id="3丶本地方法栈"><a href="#3丶本地方法栈" class="headerlink" title="3丶本地方法栈"></a>3丶本地方法栈</h2><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机执行使用到的Native方法服务，和虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。</p><h2 id="4丶Java堆"><a href="#4丶Java堆" class="headerlink" title="4丶Java堆"></a>4丶Java堆</h2><p>Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是线程共享的内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p><p>Java堆是垃圾收集器管理的主要区域，从内存回收的角度来看，由于现在收集器基本都是采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致点有Eden（伊甸园）空间丶From Survivor空间丶To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区，无论怎么划分，存储的都是对象实例，划分的目的是为了更好地回收内存，或者更快的分配内存。</p><p>Java虚拟机规范的规定中，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存完成实例分配，并且堆无法在扩展时，就会抛出OutOfMemoryError异常。</p><h2 id="5丶方法区"><a href="#5丶方法区" class="headerlink" title="5丶方法区"></a>5丶方法区</h2><p>方法去与Java堆一样，是线程共享的内存区域，它用于存储已被虚拟机加载的类信息丶常量丶静态变量丶即时编译器后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><p>由于早期HotSpot JVM的把GC分代收集扩展至方法区，因此很多人将方法去称为“永久代”。在JDK1.8中废弃永久代替换成元空间。</p><p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，虽然回收的成绩难以令人满意，类型的卸载，条件相当苛刻，但是这部分区域的回收确实的必要的。</p><p>Java虚拟机规范的规定中，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h2 id="6丶运行时常量池"><a href="#6丶运行时常量池" class="headerlink" title="6丶运行时常量池"></a>6丶运行时常量池</h2><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本丶字段丶方法丶接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。（如String类的intern()方法）。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法在申请到内存时会抛出OutOfMemoryError异常。</p><h2 id="7丶直接内存"><a href="#7丶直接内存" class="headerlink" title="7丶直接内存"></a>7丶直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁使用，而且也可能导致OutOfMemoryError异常。</p><p>在JDK 1.4中新加入了NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是。既然是内存，肯定还是会受到本机总内存的限制。。在配置虚拟机参数时，会根据实际内存设置-Xmx等参数，如果忽略直接内存的话，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。</p><p>参考文献：《Java虚拟机规范》丶《深入理解Java虚拟机》</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java 内存区域 &lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>java.util.Random的源码阅读</title>
    <link href="http://yoursite.com/2020/01/06/java.util.Random%E7%9A%84%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2020/01/06/java.util.Random的源码阅读/</id>
    <published>2020-01-06T15:01:58.000Z</published>
    <updated>2020-01-06T16:41:11.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java.util.Random的源码阅读</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>java.util.Random是Java的一个实用工具类库中的一个类，提供了产生各种类型随机数的方法</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成种子 seedUniquifier方法和System.nanoTime()时间进行 异或运算</span></span><br><span class="line">    <span class="keyword">this</span>(seedUniquifier() ^ System.nanoTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始的种子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong seedUniquifier = <span class="keyword">new</span> AtomicLong(<span class="number">8682522807148012L</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">seedUniquifier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 多线程可以会赋值失败，所以使用for循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 当前预期值</span></span><br><span class="line">        <span class="keyword">long</span> current = seedUniquifier.get();</span><br><span class="line">        <span class="comment">// 要更新的值</span></span><br><span class="line">        <span class="keyword">long</span> next = current * <span class="number">181783497276652981L</span>;</span><br><span class="line">        <span class="comment">// 使用CAS操作更新seedUniquifier</span></span><br><span class="line">        <span class="keyword">if</span> (seedUniquifier.compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong seed;</span><br><span class="line"><span class="comment">// 有参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getClass() == Random.class)</span><br><span class="line">        <span class="keyword">this</span>.seed = <span class="keyword">new</span> AtomicLong(initialScramble(seed));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 子类可以重写setSeed()方法 </span></span><br><span class="line">        <span class="keyword">this</span>.seed = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">        setSeed(seed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> multiplier = <span class="number">0x5DEECE66DL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> mask = (<span class="number">1L</span> &lt;&lt; <span class="number">48</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把用户设置的种子进行运算 返回long</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">initialScramble</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (seed ^ multiplier) &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeed</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.seed.set(initialScramble(seed));</span><br><span class="line">    haveNextNextGaussian = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 bound</span></span><br><span class="line">    <span class="keyword">if</span> (bound &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(BadBound);</span><br><span class="line">    <span class="comment">// 根据旧种子生成新种子</span></span><br><span class="line">    <span class="keyword">int</span> r = next(<span class="number">31</span>);</span><br><span class="line">    <span class="comment">// 下面这些代码都是根据新种子计算随机数</span></span><br><span class="line">    <span class="keyword">int</span> m = bound - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((bound &amp; m) == <span class="number">0</span>) </span><br><span class="line">        r = (<span class="keyword">int</span>)((bound * (<span class="keyword">long</span>)r) &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = r;</span><br><span class="line">            u - (r = u % bound) + m &lt; <span class="number">0</span>;</span><br><span class="line">            u = next(<span class="number">31</span>))</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> oldseed, nextseed;</span><br><span class="line">    AtomicLong seed = <span class="keyword">this</span>.seed;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 获取旧种子</span></span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        <span class="comment">// 用旧种子去生成新种子</span></span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">    <span class="comment">// 使用CAS，多线程下只能有一个线程更新为新种子，</span></span><br><span class="line">    <span class="comment">// 其他线程只能通过循环重新获取更新后的种子作为当前种子去计算新的种子</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：Random的实例是线程安全的，内部使用了原子类和CAS确保多线程下安全，但由于原子变量的更新是CAS操作，同时只有一个线程成功，造成了大量线程进行自旋重试操作，从而降低了并发性能</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;java.util.Random的源码阅读&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;java.util.Random是Java的一个实用工具类库中的一个类，提供了产生各种类型随机数的方法&lt;/p&gt;
    
    </summary>
    
      <category term="java.util.*" scheme="http://yoursite.com/categories/java-util/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 拦截器</title>
    <link href="http://yoursite.com/2020/01/04/mybatis%20%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://yoursite.com/2020/01/04/mybatis 拦截器/</id>
    <published>2020-01-04T15:01:58.000Z</published>
    <updated>2020-01-06T15:52:53.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学习MyBatis，学习到拦截器这块，并记录下来</p><h2 id="拦截器介绍"><a href="#拦截器介绍" class="headerlink" title="拦截器介绍"></a>拦截器介绍</h2><p>在某些业务场景下我们需要对sql进行拦截，达到不入侵原有代码下进行修改等操作，比如：分页，SQL执行时间，性能监控，数据过滤等等，在这里我们就可以用到MyBatis的Interceptor</p><a id="more"></a><p>首先自定义拦截器要实现Interceptor接口</p><p>先来个简单的一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Intercepts</span> 表明这个是个拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Signature</span> 表明要拦截的类，类里面的方法，方法里的参数</span></span><br><span class="line"><span class="comment"> * 这里要拦截的是Executor，Executor里面的update方法，方法的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Intercepts</span>(<span class="meta">@Signature</span>(type = Executor.class, method = <span class="string">"update"</span> ,args = &#123;MappedStatement.class, Object.class&#125;))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 业务逻辑....</span></span><br><span class="line">        <span class="comment">// 推进责任链前进，调用下一个拦截器拦截的方法 (责任链这里不做阐释)</span></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Interceptor 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拦截后的业务逻辑实现</span></span><br><span class="line">    <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation var1)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">    <span class="comment">// 将当前拦截器到注册到拦截器链中</span></span><br><span class="line">    <span class="function">Object <span class="title">plugin</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">    <span class="comment">// 设置自定义参数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>plugin方法在哪里被调用呢，往下看<br>下面的代码来自在org.apache.ibatis.session.Configuration类<br>作用是创建MyBatis的四大对象，可以看出方法里都调用了interceptorChain类中的pluginAll方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    parameterHandler = (ParameterHandler)<span class="keyword">this</span>.interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    <span class="keyword">return</span> parameterHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    ResultSetHandler resultSetHandler = (ResultSetHandler)<span class="keyword">this</span>.interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    StatementHandler statementHandler = (StatementHandler)<span class="keyword">this</span>.interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.newExecutor(transaction, <span class="keyword">this</span>.defaultExecutorType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? <span class="keyword">this</span>.defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Object executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cacheEnabled) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> CachingExecutor((Executor)executor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Executor executor = (Executor)<span class="keyword">this</span>.interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interceptorChain里面保存着所有拦截器<br>在pluginAll方法里调用了plugin方法在这里被调用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        Interceptor interceptor;</span><br><span class="line">        <span class="comment">// 每个拦截器都对目标对象进行代理，也就说明了拦截器只支持拦截四大对象</span></span><br><span class="line">        <span class="keyword">for</span>(Iterator var2 = <span class="keyword">this</span>.interceptors.iterator(); var2.hasNext(); target = interceptor.plugin(target)) &#123;</span><br><span class="line">            interceptor = (Interceptor)var2.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面讲完了MyBatis在哪调用了plugin方法，现在讲下怎么实现plugin方法。<br>MyBatis给我们提供了一个Plugin类用来实现我们的plugin方法，通过Plugin类的wrap()。首先通过@Intercepts@Signature注解来解析出我们需要拦截类，然后使用到了动态代理生成个代理对象返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析拦截器注解</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    <span class="comment">// 获取目标类型实现的接口</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="comment">// 利用jdk代理生成一个代理类</span></span><br><span class="line">    <span class="keyword">return</span> interfaces.length &gt; <span class="number">0</span> ? Proxy.newProxyInstance(type.getClassLoader(), interfaces, <span class="keyword">new</span> Plugin(target, interceptor, signatureMap)) : target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在invoke方法里调用到自定义拦截器的interceptor方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Set&lt;Method&gt; methods = (Set)<span class="keyword">this</span>.signatureMap.get(method.getDeclaringClass());</span><br><span class="line">        <span class="comment">// 调用拦截器的interceptor方法</span></span><br><span class="line">        <span class="keyword">return</span> methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method) ? <span class="keyword">this</span>.interceptor.intercept(<span class="keyword">new</span> Invocation(<span class="keyword">this</span>.target, method, args)) : method.invoke(<span class="keyword">this</span>.target, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(var5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在学习MyBatis，学习到拦截器这块，并记录下来&lt;/p&gt;
&lt;h2 id=&quot;拦截器介绍&quot;&gt;&lt;a href=&quot;#拦截器介绍&quot; class=&quot;headerlink&quot; title=&quot;拦截器介绍&quot;&gt;&lt;/a&gt;拦截器介绍&lt;/h2&gt;&lt;p&gt;在某些业务场景下我们需要对sql进行拦截，达到不入侵原有代码下进行修改等操作，比如：分页，SQL执行时间，性能监控，数据过滤等等，在这里我们就可以用到MyBatis的Interceptor&lt;/p&gt;
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>LRU算法</title>
    <link href="http://yoursite.com/2019/09/24/LRU%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/09/24/LRU算法/</id>
    <published>2019-09-24T13:55:36.000Z</published>
    <updated>2020-01-05T06:52:36.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学习Redis，其中用了淘汰算法，特学习下</p><h2 id="LRU介绍"><a href="#LRU介绍" class="headerlink" title="LRU介绍"></a>LRU介绍</h2><p>LRU是Least Recently Used的缩写，即最近最少使用，常用于页面置换算法，是为虚拟页式存储管理服务的。</p><p>核心：如果数据最近被访问过，那么将来访问的几率也更高</p><a id="more"></a><p><strong>利用LinkedHashMap实现</strong></p><p>1.利用LinkedHashMap中的构造方法</p><p>要完成LRU, accessOrder必须为true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.LinkedHashMap中的put方法</p><p>当accessOrder为true时，调用afterNodeAccess，将元素移动到尾部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.LinkedHashMap中的afterNodeAccess方法</p><p>将元素移动到尾部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">// 如果map里面的元素个数大于了缓存最大容量，则删除顶端元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;String, String&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">"1"</span>,<span class="string">"1"</span>);</span><br><span class="line">map.put(<span class="string">"2"</span>,<span class="string">"2"</span>);</span><br><span class="line">map.put(<span class="string">"3"</span>,<span class="string">"3"</span>);</span><br><span class="line">map.get(<span class="string">"1"</span>);</span><br><span class="line">map.get(<span class="string">"3"</span>);</span><br><span class="line">map.put(<span class="string">"4"</span>,<span class="string">"4"</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">      System.out.println(<span class="string">"key:"</span> + entry.getKey() + <span class="string">"   value:"</span> + entry.getValue());</span><br><span class="line"><span class="comment">// key:1   value:1</span></span><br><span class="line"><span class="comment">// key:3   value:3</span></span><br><span class="line"><span class="comment">// key:4   value:4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在学习Redis，其中用了淘汰算法，特学习下&lt;/p&gt;
&lt;h2 id=&quot;LRU介绍&quot;&gt;&lt;a href=&quot;#LRU介绍&quot; class=&quot;headerlink&quot; title=&quot;LRU介绍&quot;&gt;&lt;/a&gt;LRU介绍&lt;/h2&gt;&lt;p&gt;LRU是Least Recently Used的缩写，即最近最少使用，常用于页面置换算法，是为虚拟页式存储管理服务的。&lt;/p&gt;
&lt;p&gt;核心：如果数据最近被访问过，那么将来访问的几率也更高&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hbase 映射 Hive</title>
    <link href="http://yoursite.com/2019/06/30/Hbase-%E6%98%A0%E5%B0%84-Hive/"/>
    <id>http://yoursite.com/2019/06/30/Hbase-映射-Hive/</id>
    <published>2019-06-30T13:50:30.000Z</published>
    <updated>2020-01-05T06:52:47.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录下Hbase 映射 Hive的实现</p><a id="more"></a><ul><li><p>Hive内部表<br>  没被external关键字修饰，数据由Hive自身管理，hive drop掉此表时，hbase也被drop</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create TABLE person(</span><br><span class="line">       key string,</span><br><span class="line">       name string,</span><br><span class="line">       sex string</span><br><span class="line">)</span><br><span class="line">STORED BY <span class="string">'org.apache.hadoop.hive.hbase.HBaseStorageHandler'</span>   </span><br><span class="line">WITH SERDEPROPERTIES (<span class="string">"hbase.columns.mapping"</span> =<span class="string">":key,cf1:name,cf1:sex"</span>)   </span><br><span class="line">TBLPROPERTIES(<span class="string">"hbase.table.name"</span> = <span class="string">"hbase_person"</span>);</span><br></pre></td></tr></table></figure></li><li><p>Hive外部表<br> 被external关键字修饰，数据由HDFS管理，hive drop掉表，hbase表不会影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create EXTERNAL TABLE person(</span><br><span class="line">       key string,</span><br><span class="line">       name string,</span><br><span class="line">       sex string</span><br><span class="line">)</span><br><span class="line">STORED BY <span class="string">'org.apache.hadoop.hive.hbase.HBaseStorageHandler'</span>   </span><br><span class="line">WITH SERDEPROPERTIES (<span class="string">"hbase.columns.mapping"</span> =<span class="string">":key,cf1:name,cf1:sex"</span>)   </span><br><span class="line">TBLPROPERTIES(<span class="string">"hbase.table.name"</span> = <span class="string">"hbase_person"</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;记录下Hbase 映射 Hive的实现&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>记录 Hive 一些操作</title>
    <link href="http://yoursite.com/2019/06/30/%E8%AE%B0%E5%BD%95-Hive-%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/06/30/记录-Hive-一些操作/</id>
    <published>2019-06-30T13:30:56.000Z</published>
    <updated>2020-01-05T06:52:54.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前学习了Hive，特记录下一些常用操作</p><a id="more"></a><p><strong>1.创建</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建数据库</span></span><br><span class="line">create database database_name</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建表 列按‘,’分割</span></span><br><span class="line">create table table_name(id int,name string) row format delimited fields terminated by <span class="string">','</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建分区表 列按‘,’分割 按bt和country分区</span></span><br><span class="line"><span class="comment">//create external table if not exists 判断表是否存在</span></span><br><span class="line">create external table <span class="keyword">if</span> not exists table_name(id int,name string)</span><br><span class="line">partitioned by (dt <span class="built_in">String</span>,country string)</span><br><span class="line">row format delimited fields terminated by <span class="string">','</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加分区</span></span><br><span class="line">alter table table_name add <span class="keyword">if</span> not exists partition (dt=<span class="string">'xxx'</span>,country </span><br><span class="line">=<span class="string">'xxx'</span>)</span><br></pre></td></tr></table></figure><p><strong>2.查看</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询所有数据库</span></span><br><span class="line">show databases</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询所有表</span></span><br><span class="line">show tables</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看表结构</span></span><br><span class="line">desc formatted table_name</span><br></pre></td></tr></table></figure><p><a href="https://emmathe.com/2019/12/30/Hbase-映射-Hive/" target="_blank" rel="noopener">hbase映射表</a></p><p><strong>3.加载数据</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//local关键字 没有local关键字,则加载hdfs上的文件 有local关键字,则加载本地文件 </span></span><br><span class="line"><span class="comment">//overwrite关键字 覆盖数据(清空原数据)</span></span><br><span class="line"><span class="comment">//分区表，则加上partition分区</span></span><br><span class="line">load data [local] inpath <span class="string">'filepath'</span> [overwrite] into table table_name [partition(part=val,part2=val2)]</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载hdfs数据</span></span><br><span class="line">load data inpath <span class="string">'/hdfsPath'</span> into table table_name</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载本地数据</span></span><br><span class="line">load data load inpath <span class="string">'/path'</span> into table table_name</span><br></pre></td></tr></table></figure><p><strong>4.查询</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> table_name</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询分区表 where 后面加分区条件，这样做是不会扫描全表 只会查询该分区</span></span><br><span class="line">select * <span class="keyword">from</span> table_name where dt=<span class="string">'xxx'</span></span><br></pre></td></tr></table></figure><p><strong>5.删除，清空</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除数据库</span></span><br><span class="line">DROP DATABASE <span class="keyword">if</span> EXISTS table_name</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除表 </span></span><br><span class="line">DROP TABLE <span class="keyword">if</span> EXISTS table_name</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空分区表 表结构还在，只清空数据</span></span><br><span class="line">ALTER TABLE table_name DROP IF EXISTS PARTITION (dt=<span class="string">'2018-08'</span>,country=<span class="string">'CH'</span>)</span><br></pre></td></tr></table></figure><p><strong>6.重命名</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重命名表名</span></span><br><span class="line">ALTER TABLE table_name_old RENAME TO table_name_new</span><br><span class="line"></span><br><span class="line"><span class="comment">//重命名列名</span></span><br><span class="line">ALTER TABLE table_name CHANGE col_old_name col_new_name STRING;</span><br></pre></td></tr></table></figure><p><strong>7.导出文件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导出文件到hdfs上 按照‘,’分割 </span></span><br><span class="line"><span class="comment">//overwrite关键字 会覆盖目录下的原数据</span></span><br><span class="line">INSERT OVERWRITE directory <span class="string">'/hdfsPath'</span> row format delimited fields terminated by <span class="string">','</span>  SELECT * <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure><p><strong>8.无效ID在关联时的数据倾斜问题</strong></p><ul><li>解决方法：函数过滤 null</li></ul><p>把空值的id变成一个字符串加上随机数，就能把倾斜的数据分到不同的Reduce上，从而解决数据倾斜问题。因为空值不参与关联，即使分到不同 的 Reduce 上，也不会影响最终的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tableName1 a LEFT OUTER </span><br><span class="line">JOIN tableName2 b ON </span><br><span class="line">CASE WHEN a.id IS NULL THEN CONCAT(<span class="string">'hive_temp_id'</span>,RAND()) ELSE a.id END =b.user_id;</span><br></pre></td></tr></table></figure><p><strong>9.Hive不允许直接访问非group by字段</strong></p><ul><li>对于非group by字段，可以使用collect_set函数收集这些字段，返回一个数组；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT a,b FROM tableName GROUP BY a<span class="comment">//Expression not in GROUP BY key 'b'</span></span><br><span class="line"></span><br><span class="line">SELECT a,collect_set(b) FROM tableName GROUP BY a<span class="comment">//正确的使用方式</span></span><br></pre></td></tr></table></figure><ul><li>collect_set函数的其他用法：</li></ul><p>使用数字下标，可以直接访问数组中的元素</p><p><strong>10.控制map和reduce数量</strong></p><ul><li><p>控制map</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> mapred.max.split.size=256000000;   //每个Map处理的最大输入文件大小(256MB)</span><br><span class="line"><span class="keyword">set</span> mapred.min.split.size.per.node=1;  //节点上split文件的最小值</span><br><span class="line"><span class="keyword">set</span> mapred.min.split.size.per.rack=1;  //机架上split文件的最小值</span><br></pre></td></tr></table></figure></li><li><p>控制reduce</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">set</span> mapred.reduce.tasks=10;  //设置reduce的数量</span><br><span class="line">//方法二</span><br><span class="line"><span class="keyword">set</span> hive.exec.reducers.bytes.per.reducer=1073741824 //每个reduce处理的数据量,默认1GB</span><br></pre></td></tr></table></figure></li></ul><p><strong>10.hive join 优化的方式</strong></p><ul><li>map join<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.auto.convert.join=true //自动MAPJOIN转换操作（common join转换为map join</span><br></pre></td></tr></table></figure></li></ul><p><strong>12.合并小文件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive.merge.mapfiles = <span class="literal">true</span><span class="comment">//和并 Map 输出文件，默认为 True</span></span><br><span class="line">hive.merge.mapredfiles = <span class="literal">false</span> <span class="comment">//合并 Reduce 输出文件，默认为 False</span></span><br><span class="line">hive.merge.size.per.task = <span class="number">256</span>*<span class="number">1000</span>*<span class="number">1000</span> <span class="comment">//合并文件的大小。</span></span><br></pre></td></tr></table></figure><p><strong>13.并行执行优化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.exec.parallel=true; //开启任务并行执行</span><br><span class="line"><span class="keyword">set</span> hive.exec.parallel.thread.number=8; //同一个sql允许并行任务的最大线程数</span><br><span class="line"><span class="keyword">set</span> hive.groupby.skewindata=true; //设置数据负载均衡，防止数据倾斜</span><br><span class="line"><span class="keyword">set</span> hive.ignore.mapjoin.hint=false;//不忽略MAPJOIN标记</span><br><span class="line"><span class="keyword">set</span> mapred.reduce.tasks=15;//设置reduce的数量</span><br><span class="line"><span class="keyword">set</span> hive.exec.reducers.max=200;//reduce最大数量(默认999)</span><br><span class="line"><span class="keyword">set</span> hive.auto.convert.join=false;//自动MAPJOIN转换操作（common join转换为map join）</span><br><span class="line"><span class="keyword">set</span> hive.exec.compress.intermediate=true; //hive的压缩设置，中间结果压缩  </span><br><span class="line"><span class="keyword">set</span> hive.map.aggr = true;//map中做部分聚集操作(默认true)</span><br><span class="line"><span class="keyword">set</span> hive.execution.engine=tez;//更改hive底层执行的计算框架</span><br></pre></td></tr></table></figure><p>填坑中</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前学习了Hive，特记录下一些常用操作&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
</feed>
